{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"A native plotting widget for Textual apps","text":"<p>Textual is an excellent Python framework for building applications in the terminal, or on the web. This library provides a plot widget which your app can use to plot all kinds of quantitative data. So, no pie charts, sorry. The widget support scatter plots and line plots, and can also draw using high-resolution characters like unicode half blocks, quadrants and 8-dot Braille characters. It may still be apparent that these are drawn using characters that take up a full block in the terminal, especially when plot series overlap. However, the use of these characters can reduce the line thickness and improve the resolution tremendously.</p>"},{"location":"#screenshots","title":"Screenshots","text":"<p>The daytime spectrum dataset shows the visible-light spectrum recorded by an Ocean Optics USB2000+ spectrometer using the DeadSea Optics software. It was taken in the morning while the detector was facing my office window.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Line plots</li> <li>Scatter plots</li> <li>Automatic scaling and tick placement at nice intervals (1, 2, 5, etc.)</li> <li>Axes labels</li> <li>High-resolution modes using unicode half blocks (1x2), quadrants (2x2) and braille (2x8) characters</li> <li>Mouse support for zooming (mouse scrolling) and panning (mouse dragging)</li> <li>Horizontal- or vertical-only zooming and panning when the mouse cursor is in the plot margins</li> </ul>"},{"location":"#running-the-demo-installation","title":"Running the demo / installation","text":"<p>Using uv:</p> <pre><code>uvx textual-plot\n</code></pre> <p>Using pipx:</p> <pre><code>pipx run textual-plot\n</code></pre> <p>Install the package with either</p> <pre><code>uv tool install textual-plot\n</code></pre> <p>or</p> <pre><code>pipx install textual-plot\n</code></pre> <p>Alternatively, install the package with <code>pip</code> (please, use virtual environments) and run the demo:</p> <pre><code>pip install textual-plot\n</code></pre> <p>In all cases, you can run the demo with</p> <pre><code>textual-plot\n</code></pre>"},{"location":"#tutorial","title":"Tutorial","text":"<p>A minimal example is shown below: </p> <pre><code>from textual.app import App, ComposeResult\n\nfrom textual_plot import PlotWidget\n\n\nclass MinimalApp(App[None]):\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        plot = self.query_one(PlotWidget)\n        plot.plot(x=[0, 1, 2, 3, 4], y=[0, 1, 4, 9, 16])\n\n\nMinimalApp().run()\n</code></pre> <p>You include a <code>PlotWidget</code> in your compose method and after your UI has finished composing, you can start plotting data. The <code>plot()</code> method takes <code>x</code> and <code>y</code> data which should be array-like. It can be lists, or NumPy arrays, or really anything that can be turned into a NumPy array which is what's used internally. The <code>plot()</code> method further accepts a <code>line_style</code> argument which accepts Textual styles like <code>\"white\"</code>, <code>\"red on blue3\"</code>, etc. For standard low-resolution plots, it does not make much sense to specify a background color since the text character used for plotting is a full block filling an entire cell.</p>"},{"location":"#high-resolution-plotting","title":"High-resolution plotting","text":"<p>The plot widget supports high-resolution plotting where the character does not take up the full cell:</p> <p></p> <pre><code>from textual.app import App, ComposeResult\n\nfrom textual_plot import HiResMode, PlotWidget\n\n\nclass MinimalApp(App[None]):\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        plot = self.query_one(PlotWidget)\n        plot.plot(\n            x=[0, 1, 2, 3, 4],\n            y=[0, 1, 4, 9, 16],\n            hires_mode=HiResMode.BRAILLE,\n            line_style=\"bright_yellow on blue3\",\n        )\n\n\nMinimalApp().run()\n</code></pre> <p>Admittedly, you'll be mostly plotting with foreground colors only. The plot widget supports four high-resolution modes: <code>Hires.BRAILLE</code> (2x8), <code>HiRes.HALFBLOCK</code> (1x2) and <code>HiRes.QUADRANT</code> (2x2) where the size between brackets is the number of 'pixels' inside a single cell.</p>"},{"location":"#scatter-plots","title":"Scatter plots","text":"<p>To create scatter plots, use the <code>scatter()</code> method, which accepts a <code>marker</code> argument which can be any unicode character (as long as it is one cell wide, which excludes many emoji characters and non-Western scripts): </p> <pre><code>import numpy as np\nfrom textual.app import App, ComposeResult\n\nfrom textual_plot import PlotWidget\n\n\nclass MinimalApp(App[None]):\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        rng = np.random.default_rng(seed=4)\n        plot = self.query_one(PlotWidget)\n\n        x = np.linspace(0, 10, 21)\n        y = 0.2 * x - 1 + rng.normal(loc=0.0, scale=0.2, size=len(x))\n        plot.scatter(x, y, marker=\"\u29bf\")\n\n\nMinimalApp().run()\n</code></pre>"},{"location":"#the-full-demo-code","title":"The full demo code","text":"<p>Finally, the code of the demo is given below, showing how you can handle multiple plots and updating 'live' data:</p> <pre><code>import importlib.resources\nimport itertools\n\nimport numpy as np\nfrom textual.app import App, ComposeResult\nfrom textual.containers import Container\nfrom textual.widgets import Footer, Header, TabbedContent, TabPane\nfrom textual_hires_canvas import HiResMode\n\nfrom textual_plot import PlotWidget\n\n\nclass SpectrumPlot(Container):\n    BINDINGS = [(\"m\", \"cycle_modes\", \"Cycle Modes\")]\n\n    _modes = itertools.cycle(\n        [HiResMode.QUADRANT, HiResMode.BRAILLE, None, HiResMode.HALFBLOCK]\n    )\n    mode = next(_modes)\n\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        # Read CSV data included with this package\n        self.spectrum_csv = importlib.resources.read_text(\n            \"textual_plot.resources\", \"morning-spectrum.csv\"\n        ).splitlines()\n\n        # plot the spectrum and set ymin limit once\n        self.plot_spectrum()\n        self.query_one(PlotWidget).set_ylimits(ymin=0)\n\n    def plot_spectrum(self) -&gt; None:\n        x, y = np.genfromtxt(\n            self.spectrum_csv,\n            delimiter=\",\",\n            names=True,\n            unpack=True,\n        )\n\n        plot = self.query_one(PlotWidget)\n        plot.clear()\n        plot.plot(x, y, hires_mode=self.mode)\n        plot.set_xlabel(\"Wavelength (nm)\")\n        plot.set_ylabel(\"Intensity\")\n\n    def action_cycle_modes(self) -&gt; None:\n        self.mode = next(self._modes)\n        self.plot_spectrum()\n\n\nclass SinePlot(Container):\n    _phi: float = 0.0\n\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        self._timer = self.set_interval(1 / 24, self.plot_moving_sines, pause=True)\n\n    def on_show(self) -&gt; None:\n        self._timer.resume()\n\n    def on_hide(self) -&gt; None:\n        self._timer.pause()\n\n    def plot_moving_sines(self) -&gt; None:\n        plot = self.query_one(PlotWidget)\n        plot.clear()\n        x = np.linspace(0, 10, 41)\n        y = x**2 / 3.5\n        plot.scatter(\n            x,\n            y,\n            marker_style=\"blue\",\n            # marker=\"*\",\n            hires_mode=HiResMode.QUADRANT,\n        )\n        x = np.linspace(0, 10, 200)\n        plot.plot(\n            x=x,\n            y=10 + 10 * np.sin(x + self._phi),\n            line_style=\"blue\",\n            hires_mode=None,\n        )\n\n        plot.plot(\n            x=x,\n            y=10 + 10 * np.sin(x + self._phi + 1),\n            line_style=\"red3\",\n            hires_mode=HiResMode.HALFBLOCK,\n        )\n        plot.plot(\n            x=x,\n            y=10 + 10 * np.sin(x + self._phi + 2),\n            line_style=\"green\",\n            hires_mode=HiResMode.QUADRANT,\n        )\n        plot.plot(\n            x=x,\n            y=10 + 10 * np.sin(x + self._phi + 3),\n            line_style=\"yellow\",\n            hires_mode=HiResMode.BRAILLE,\n        )\n\n        self._phi += 0.1\n\n\nclass DemoApp(App[None]):\n    AUTO_FOCUS = \"PlotWidget\"\n\n    def compose(self) -&gt; ComposeResult:\n        yield Header()\n        yield Footer()\n        with TabbedContent():\n            with TabPane(\"Daytime spectrum\"):\n                yield SpectrumPlot()\n            with TabPane(\"Moving sines\"):\n                yield SinePlot()\n\n\ndef main():\n    app = DemoApp()\n    app.run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#list-of-important-plot-widget-methods","title":"List of important plot widget methods","text":"<ul> <li><code>clear()</code>: clear the plot.</li> <li><code>plot(x, y, line_style, hires_mode, label)</code>: plot a dataset with a line using the specified linestyle and high-resolution mode.</li> <li><code>scatter(x, y, marker, marker_style, hires_mode, label)</code>: plot a dataset with markers using the specified marker, marker style and high-resolution mode.</li> <li><code>set_xlimits(xmin, xmax)</code>: set the x-axis limits. <code>None</code> means autoscale.</li> <li><code>set_ylimits(xmin, xmax)</code>: set the y-axis limits. <code>None</code> means autoscale.</li> <li><code>set_xticks(ticks)</code>: manually specify x-axis tick locations.</li> <li><code>set_yticks(ticks)</code>: manually specify y-axis tick locations.</li> <li><code>set_xlabel(label)</code>: set the x-axis label.</li> <li><code>set_ylabel(label)</code>: set the y-axis label.</li> <li><code>show_legend(location, is_visible)</code>: show or hide the plot legend.</li> </ul> <p>Various other methods exist, mostly for coordinate transformations and handling UI events to zoom and pan the plot.</p>"},{"location":"#alternatives","title":"Alternatives","text":"<p>Textual-plotext uses the plotext library which has more features than this library. However, it does not support interactive zooming or panning and the tick placement isn't as nice since it simply divides up the axes range into a fixed number of intervals giving values like 0, 123.4, 246.8, etc.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>The performance can be much improved, but we're working on that. Next, we'll work on adding some features like date axes. This will (probably) not turn into a general do-it-all plotting library. We focus first on handling quantitative data in the context of physics experiments. If you'd like to see features added, do let us know. And if a PR is of good quality and is a good fit for the API, we'd love to handle more use cases beyond physics. And who knows, maybe this will turn into a general plotting library!</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#textual_plot.HiResMode","title":"<code>HiResMode</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>.venv/lib/python3.10/site-packages/textual_hires_canvas/hires.py</code> <pre><code>class HiResMode(enum.Enum):\n    HALFBLOCK = enum.auto()\n    QUADRANT = enum.auto()\n    BRAILLE = enum.auto()\n</code></pre>"},{"location":"reference/#textual_plot.LegendLocation","title":"<code>LegendLocation</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enum to specify the location of the legend in the plot widget.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>class LegendLocation(enum.Enum):\n    \"\"\"An enum to specify the location of the legend in the plot widget.\"\"\"\n\n    TOPLEFT = enum.auto()\n    TOPRIGHT = enum.auto()\n    BOTTOMLEFT = enum.auto()\n    BOTTOMRIGHT = enum.auto()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget","title":"<code>PlotWidget</code>","text":"<p>               Bases: <code>Widget</code></p> <p>A plot widget for Textual apps.</p> <p>This widget supports high-resolution line and scatter plots, has nice ticks at 1, 2, 5, 10, 20, 50, etc. intervals and supports zooming and panning with your pointer device.</p> <p>The following component classes can be used to style the widget:</p> Class Description <code>plot--axis</code> Style of the axes (may be used to change the color). <code>plot--tick</code> Style of the tick labels along the axes. <code>plot--label</code> Style of axis labels. Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>class PlotWidget(Widget, can_focus=True):\n    \"\"\"A plot widget for Textual apps.\n\n    This widget supports high-resolution line and scatter plots, has nice ticks\n    at 1, 2, 5, 10, 20, 50, etc. intervals and supports zooming and panning with\n    your pointer device.\n\n    The following component classes can be used to style the widget:\n\n    | Class | Description |\n    | :- | :- |\n    | `plot--axis` | Style of the axes (may be used to change the color). |\n    | `plot--tick` | Style of the tick labels along the axes. |\n    | `plot--label` | Style of axis labels. |\n    \"\"\"\n\n    @dataclass\n    class ScaleChanged(Message):\n        plot: \"PlotWidget\"\n        x_min: float\n        x_max: float\n        y_min: float\n        y_max: float\n\n    COMPONENT_CLASSES = {\"plot--axis\", \"plot--tick\", \"plot--label\"}\n\n    DEFAULT_CSS = \"\"\"\n        PlotWidget {\n            layers: plot legend;\n\n            &amp;:focus &gt; .plot--axis {\n                color: $primary;\n            }\n\n            &amp; &gt; .plot--axis {\n                color: $secondary;\n            }\n\n            &amp; &gt; .plot--tick {\n                color: $secondary;\n                text-style: bold;\n            }\n\n            &amp; &gt; .plot--label {\n                color: $primary;\n                text-style: bold italic;\n            }\n\n            Grid {\n                layer: plot;\n                grid-size: 2 3;\n\n                #margin-top, #margin-bottom {\n                    column-span: 2;\n                }\n            }\n\n            #legend {\n              layer: legend;\n              width: auto;\n              border: solid white;\n              display: none;\n\n              &amp;.dragged {\n                border: heavy yellow;\n              }\n            }\n        }\n    \"\"\"\n\n    BINDINGS = [(\"r\", \"reset_scales\", \"Reset scales\")]\n\n    margin_top = reactive(2)\n    margin_bottom = reactive(3)\n    margin_left = reactive(10)\n\n    _datasets: list[DataSet]\n    _labels: list[str | None]\n\n    _user_x_min: float | None = None\n    _user_x_max: float | None = None\n    _user_y_min: float | None = None\n    _user_y_max: float | None = None\n    _auto_x_min: bool = True\n    _auto_x_max: bool = True\n    _auto_y_min: bool = True\n    _auto_y_max: bool = True\n    _x_min: float = 0.0\n    _x_max: float = 1.0\n    _y_min: float = 0.0\n    _y_max: float = 1.0\n\n    _x_ticks: Sequence[float] | None = None\n    _y_ticks: Sequence[float] | None = None\n\n    _scale_rectangle: Region = Region(0, 0, 0, 0)\n    _legend_location: LegendLocation = LegendLocation.TOPRIGHT\n    _legend_relative_offset: Offset = Offset(0, 0)\n\n    _x_label: str = \"\"\n    _y_label: str = \"\"\n\n    _allow_pan_and_zoom: bool = True\n    _is_dragging_legend: bool = False\n    _needs_rerender: bool = False\n\n    def __init__(\n        self,\n        name: str | None = None,\n        id: str | None = None,\n        classes: str | None = None,\n        *,\n        allow_pan_and_zoom: bool = True,\n        invert_mouse_wheel: bool = False,\n        disabled: bool = False,\n    ) -&gt; None:\n        \"\"\"Initializes the plot widget with basic widget parameters.\n\n        Params:\n            name: The name of the widget.\n            id: The ID of the widget in the DOM.\n            classes: The CSS classes for the widget.\n            allow_pan_and_zoom: Whether to allow panning and zooming the plot.\n                Defaults to True.\n            invert_mouse_wheel: When set to True the zooming direction is inverted\n                when scrolling in and out of the widget. Defaults to False.\n            disabled: Whether the widget is disabled or not.\n        \"\"\"\n        super().__init__(\n            name=name,\n            id=id,\n            classes=classes,\n            disabled=disabled,\n        )\n        self._datasets = []\n        self._labels = []\n        self._v_lines: list[VLinePlot] = []\n        self._v_lines_labels: list[str | None] = []\n        self._allow_pan_and_zoom = allow_pan_and_zoom\n        self.invert_mouse_wheel = invert_mouse_wheel\n\n    def compose(self) -&gt; ComposeResult:\n        with Grid():\n            yield Canvas(1, 1, id=\"margin-top\")\n            yield Canvas(1, 1, id=\"margin-left\")\n            yield Canvas(1, 1, id=\"plot\")\n            yield Canvas(1, 1, id=\"margin-bottom\")\n        yield Legend(id=\"legend\")\n\n    def on_mount(self) -&gt; None:\n        self._update_margin_sizes()\n        self.set_xlimits(None, None)\n        self.set_ylimits(None, None)\n        self.clear()\n\n    @on(Focus)\n    @on(Blur)\n    def rerender(self) -&gt; None:\n        self.refresh(layout=True)\n\n    def _on_canvas_resize(self, event: Canvas.Resize) -&gt; None:\n        if event.canvas.id == \"plot\":\n            # The scale rectangle falls just inside the axis rectangle\n            self._scale_rectangle = Region(\n                1, 1, event.size.width - 2, event.size.height - 2\n            )\n        event.canvas.reset(size=event.size)\n        self._position_legend()\n        self.refresh(layout=True)\n\n    def watch_margin_top(self) -&gt; None:\n        self._update_margin_sizes()\n\n    def watch_margin_bottom(self) -&gt; None:\n        self._update_margin_sizes()\n\n    def watch_margin_left(self) -&gt; None:\n        self._update_margin_sizes()\n\n    def _update_margin_sizes(self) -&gt; None:\n        \"\"\"Update grid layout taking plot margins into account.\"\"\"\n        grid = self.query_one(Grid)\n        grid.styles.grid_columns = f\"{self.margin_left} 1fr\"\n        grid.styles.grid_rows = f\"{self.margin_top} 1fr {self.margin_bottom}\"\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear the plot canvas.\"\"\"\n        self._datasets = []\n        self._labels = []\n        self._v_lines = []\n        self._v_lines_labels = []\n        self.refresh(layout=True)\n\n    def plot(\n        self,\n        x: ArrayLike,\n        y: ArrayLike,\n        line_style: str = \"white\",\n        hires_mode: HiResMode | None = None,\n        label: str | None = None,\n    ) -&gt; None:\n        \"\"\"Graph dataset using a line plot.\n\n        If you supply hires_mode, the dataset will be plotted using one of the\n        available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n        characters.\n\n        Args:\n            x: An ArrayLike with the data values for the horizontal axis.\n            y: An ArrayLike with the data values for the vertical axis.\n            line_style: A string with the style of the line. Defaults to\n                \"white\".\n            hires_mode: A HiResMode enum or None to plot with full-height\n                blocks. Defaults to None.\n            label: A string with the label for the dataset. Defaults to None.\n        \"\"\"\n        x, y = drop_nans_and_infs(np.array(x), np.array(y))\n        self._datasets.append(\n            LinePlot(\n                x=x,\n                y=y,\n                line_style=line_style,\n                hires_mode=hires_mode,\n            )\n        )\n        self._labels.append(label)\n        self.refresh(layout=True)\n\n    def scatter(\n        self,\n        x: ArrayLike,\n        y: ArrayLike,\n        marker: str = \"o\",\n        marker_style: str = \"white\",\n        hires_mode: HiResMode | None = None,\n        label: str | None = None,\n    ) -&gt; None:\n        \"\"\"Graph dataset using a scatter plot.\n\n        If you supply hires_mode, the dataset will be plotted using one of the\n        available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n        characters.\n\n        Args:\n            x: An ArrayLike with the data values for the horizontal axis.\n            y: An ArrayLike with the data values for the vertical axis.\n            marker: A string with the character to print as the marker.\n            marker_style: A string with the style of the marker. Defaults to\n                \"white\".\n            hires_mode: A HiResMode enum or None to plot with the supplied\n                marker. Defaults to None.\n            label: A string with the label for the dataset. Defaults to None.\n        \"\"\"\n        x, y = drop_nans_and_infs(np.array(x), np.array(y))\n        self._datasets.append(\n            ScatterPlot(\n                x=x,\n                y=y,\n                marker=marker,\n                marker_style=marker_style,\n                hires_mode=hires_mode,\n            )\n        )\n        self._labels.append(label or \"\")\n        self.refresh(layout=True)\n\n    def add_v_line(\n        self, x: float, line_style: str = \"white\", label: str | None = None\n    ) -&gt; None:\n        \"\"\"Draw a vertical line on the plot.\n\n        Args:\n            x: The x-coordinate where the vertical line will be placed.\n            line_style: A string with the style of the line. Defaults to \"white\".\n            label: A string with the label for the line. Defaults to None.\n        \"\"\"\n        self._v_lines.append(VLinePlot(x=x, line_style=line_style))\n        self._v_lines_labels.append(label)\n        self.refresh(layout=True)\n\n    def set_xlimits(self, xmin: float | None = None, xmax: float | None = None) -&gt; None:\n        \"\"\"Set the limits of the x axis.\n\n        Args:\n            xmin: A float with the minimum x value or None for autoscaling.\n                Defaults to None.\n            xmax: A float with the maximum x value or None for autoscaling.\n                Defaults to None.\n        \"\"\"\n        self._user_x_min = xmin\n        self._user_x_max = xmax\n        self._auto_x_min = xmin is None\n        self._auto_x_max = xmax is None\n        self._x_min = xmin if xmin is not None else 0.0\n        self._x_max = xmax if xmax is not None else 1.0\n        self.refresh(layout=True)\n\n    def set_ylimits(self, ymin: float | None = None, ymax: float | None = None) -&gt; None:\n        \"\"\"Set the limits of the y axis.\n\n        Args:\n            ymin: A float with the minimum y value or None for autoscaling.\n                Defaults to None.\n            ymax: A float with the maximum y value or None for autoscaling.\n                Defaults to None.\n        \"\"\"\n        self._user_y_min = ymin\n        self._user_y_max = ymax\n        self._auto_y_min = ymin is None\n        self._auto_y_max = ymax is None\n        self._y_min = ymin if ymin is not None else 0.0\n        self._y_max = ymax if ymax is not None else 1.0\n        self.refresh(layout=True)\n\n    def set_xlabel(self, label: str) -&gt; None:\n        \"\"\"Set a label for the x axis.\n\n        Args:\n            label: A string with the label text.\n        \"\"\"\n        self._x_label = label\n\n    def set_ylabel(self, label: str) -&gt; None:\n        \"\"\"Set a label for the y axis.\n\n        Args:\n            label: A string with the label text.\n        \"\"\"\n        self._y_label = label\n\n    def set_xticks(self, ticks: Sequence[float] | None = None) -&gt; None:\n        \"\"\"Set the x axis ticks.\n\n        Use None for autoscaling, an empty list to hide the ticks.\n\n        Args:\n            ticks: An iterable with the tick values.\n        \"\"\"\n        self._x_ticks = ticks\n\n    def set_yticks(self, ticks: Sequence[float] | None = None) -&gt; None:\n        \"\"\"Set the y axis ticks.\n\n        Use None for autoscaling, an empty list to hide the ticks.\n\n        Args:\n            ticks: An iterable with the tick values.\n        \"\"\"\n        self._y_ticks = ticks\n\n    def show_legend(\n        self,\n        location: LegendLocation = LegendLocation.TOPRIGHT,\n        is_visible: bool = True,\n    ) -&gt; None:\n        \"\"\"Show or hide the legend for the datasets in the plot.\n\n        Args:\n            is_visible: A boolean indicating whether to show the legend.\n                Defaults to True.\n        \"\"\"\n        self.query_one(\"#legend\", Static).display = is_visible\n        if not is_visible:\n            return\n\n        self._position_legend()\n\n        legend_lines = []\n        if isinstance(location, LegendLocation):\n            self._legend_location = location\n        else:\n            raise TypeError(\n                f\"Expected LegendLocation, got {type(location).__name__} instead.\"\n            )\n\n        for label, dataset in zip(self._labels, self._datasets):\n            if label is not None:\n                if isinstance(dataset, ScatterPlot):\n                    marker = (\n                        dataset.marker\n                        if dataset.hires_mode is None\n                        else LEGEND_MARKER[dataset.hires_mode]\n                    ).center(3)\n                    style = dataset.marker_style\n                elif isinstance(dataset, LinePlot):\n                    marker = LEGEND_LINE[dataset.hires_mode]\n                    style = dataset.line_style\n                else:\n                    # unsupported dataset type\n                    continue\n                text = Text(marker)\n                text.stylize(style)\n                text.append(f\" {label}\")\n                legend_lines.append(text.markup)\n\n        for label, vline in zip(self._v_lines_labels, self._v_lines):\n            if label is not None:\n                marker = \"\u2502\".center(3)\n                style = vline.line_style\n                text = Text(marker)\n                text.stylize(style)\n                text.append(f\" {label}\")\n                legend_lines.append(text.markup)\n\n        self.query_one(\"#legend\", Static).update(\n            Text.from_markup(\"\\n\".join(legend_lines))\n        )\n\n    def _position_legend(self) -&gt; None:\n        \"\"\"Position the legend in the plot widget using absolute offsets.\n\n        The position of the legend is calculated by checking the legend origin\n        location (top left, bottom right, etc.) and an offset resulting from the\n        user dragging the legend to another location. Then the nearest corner of\n        the plot widget is determined and the legend is anchored to that corner\n        and a new relative offset is determined. The end result is that the user\n        can place the legend anywhere in the plot, but when the user resizes the\n        plot the legend will stay fixed relative to the nearest corner.\n        \"\"\"\n\n        position = (\n            self._get_legend_origin_coordinates(self._legend_location)\n            + self._legend_relative_offset\n        )\n        distances: dict[LegendLocation, float] = {\n            location: self._get_legend_origin_coordinates(location).get_distance_to(\n                position\n            )\n            for location in LegendLocation\n        }\n        nearest_location = min(distances, key=lambda loc: distances[loc])\n        self._legend_location = nearest_location\n        self._legend_relative_offset = position - self._get_legend_origin_coordinates(\n            nearest_location\n        )\n\n        legend = self.query_one(\"#legend\", Static)\n        legend.offset = position\n\n    def _get_legend_origin_coordinates(self, location: LegendLocation) -&gt; Offset:\n        \"\"\"Calculate the (x, y) origin coordinates for positioning the legend.\n\n        The coordinates are determined based on the legend's location (top-left,\n        top-right, bottom-left, bottom-right), the size of the data rectangle,\n        the length of the legend labels, and the margins and border spacing.\n        User adjustments (dragging the legend to a different position) are _not_\n        taken into account, but are applied later.\n\n        Returns:\n            A (x, y) tuple of ints representing the coordinates of the top-left\n            corner of the legend within the plot widget.\n        \"\"\"\n        canvas = self.query_one(\"#plot\", Canvas)\n        legend = self.query_one(\"#legend\", Static)\n\n        labels = [label for label in self._labels if label is not None]\n        # markers and lines in the legend are 3 characters wide, plus a space, so 4\n        max_length = 4 + max((len(s) for s in labels), default=0)\n\n        if location in (LegendLocation.TOPLEFT, LegendLocation.BOTTOMLEFT):\n            x0 = self.margin_left + 1\n        else:\n            # LegendLocation is TOPRIGHT or BOTTOMRIGHT\n            x0 = self.margin_left + canvas.size.width - 1 - max_length\n            # leave room for the border\n            x0 -= legend.styles.border.spacing.left + legend.styles.border.spacing.right\n\n        if location in (LegendLocation.TOPLEFT, LegendLocation.TOPRIGHT):\n            y0 = self.margin_top + 1\n        else:\n            # LegendLocation is TOPRIGHT or BOTTOMRIGHT\n            y0 = self.margin_top + canvas.size.height - 1 - len(labels)\n            # leave room for the border\n            y0 -= legend.styles.border.spacing.top + legend.styles.border.spacing.bottom\n        return Offset(x0, y0)\n\n    def refresh(\n        self,\n        *regions: Region,\n        repaint: bool = True,\n        layout: bool = False,\n        recompose: bool = False,\n    ) -&gt; Self:\n        \"\"\"Refresh the widget.\"\"\"\n        if layout is True:\n            self._needs_rerender = True\n        return super().refresh(\n            *regions, repaint=repaint, layout=layout, recompose=recompose\n        )\n\n    def render(self) -&gt; RenderResult:\n        if self._needs_rerender:\n            self._needs_rerender = False\n            self._render_plot()\n        return \"\"\n\n    def _render_plot(self) -&gt; None:\n        try:\n            if (canvas := self.query_one(\"#plot\", Canvas))._canvas_size is None:\n                return\n        except NoMatches:\n            # Refresh is called before the widget is composed\n            return\n\n        # clear canvas\n        canvas.reset()\n\n        # determine axis limits\n        if self._datasets or self._v_lines:\n            xs = [dataset.x for dataset in self._datasets]\n            if self._v_lines:\n                xs.append(np.array([vline.x for vline in self._v_lines]))\n            ys = [dataset.y for dataset in self._datasets]\n            if self._auto_x_min:\n                non_empty_xs = [x for x in xs if len(x) &gt; 0]\n                if non_empty_xs:\n                    self._x_min = float(np.min([np.min(x) for x in non_empty_xs]))\n            if self._auto_x_max:\n                non_empty_xs = [x for x in xs if len(x) &gt; 0]\n                if non_empty_xs:\n                    self._x_max = float(np.max([np.max(x) for x in non_empty_xs]))\n            if self._auto_y_min:\n                non_empty_ys = [y for y in ys if len(y) &gt; 0]\n                if non_empty_ys:\n                    self._y_min = float(np.min([np.min(y) for y in non_empty_ys]))\n            if self._auto_y_max:\n                non_empty_ys = [y for y in ys if len(y) &gt; 0]\n                if non_empty_ys:\n                    self._y_max = float(np.max([np.max(y) for y in non_empty_ys]))\n\n            if self._x_min == self._x_max:\n                self._x_min -= 1e-6\n                self._x_max += 1e-6\n            if self._y_min == self._y_max:\n                self._y_min -= 1e-6\n                self._y_max += 1e-6\n\n        # render datasets\n        for dataset in self._datasets:\n            if isinstance(dataset, ScatterPlot):\n                self._render_scatter_plot(dataset)\n            elif isinstance(dataset, LinePlot):\n                self._render_line_plot(dataset)\n\n        # render vlines\n        for vline in self._v_lines:\n            self._render_v_line_plot(vline)\n\n        # render axis, ticks and labels\n        canvas.draw_rectangle_box(\n            0,\n            0,\n            canvas.size.width - 1,\n            canvas.size.height - 1,\n            thickness=2,\n            style=str(self.get_component_rich_style(\"plot--axis\")),\n        )\n        self._render_x_ticks()\n        self._render_y_ticks()\n        self._render_x_label()\n        self._render_y_label()\n\n    def _render_scatter_plot(self, dataset: ScatterPlot) -&gt; None:\n        canvas = self.query_one(\"#plot\", Canvas)\n        if dataset.hires_mode:\n            hires_pixels = [\n                self.get_hires_pixel_from_coordinate(xi, yi)\n                for xi, yi in zip(dataset.x, dataset.y)\n            ]\n            canvas.set_hires_pixels(\n                hires_pixels, style=dataset.marker_style, hires_mode=dataset.hires_mode\n            )\n        else:\n            pixels = [\n                self.get_pixel_from_coordinate(xi, yi)\n                for xi, yi in zip(dataset.x, dataset.y)\n            ]\n            for pixel in pixels:\n                canvas.set_pixel(\n                    *pixel, char=dataset.marker, style=dataset.marker_style\n                )\n\n    def _render_line_plot(self, dataset: LinePlot) -&gt; None:\n        canvas = self.query_one(\"#plot\", Canvas)\n\n        if dataset.hires_mode:\n            hires_pixels = [\n                self.get_hires_pixel_from_coordinate(xi, yi)\n                for xi, yi in zip(dataset.x, dataset.y)\n            ]\n            coordinates = [\n                (*hires_pixels[i - 1], *hires_pixels[i])\n                for i in range(1, len(hires_pixels))\n            ]\n            canvas.draw_hires_lines(\n                coordinates, style=dataset.line_style, hires_mode=dataset.hires_mode\n            )\n        else:\n            pixels = [\n                self.get_pixel_from_coordinate(xi, yi)\n                for xi, yi in zip(dataset.x, dataset.y)\n            ]\n            for i in range(1, len(pixels)):\n                canvas.draw_line(*pixels[i - 1], *pixels[i], style=dataset.line_style)\n\n    def _render_v_line_plot(self, vline: VLinePlot) -&gt; None:\n        canvas = self.query_one(\"#plot\", Canvas)\n        start = self.get_pixel_from_coordinate(vline.x, self._y_min)\n        end = self.get_pixel_from_coordinate(vline.x, self._y_max)\n        canvas.draw_line(\n            start[0], start[1], end[0], end[1], style=vline.line_style, char=\"\u2502\"\n        )\n\n    def _render_x_ticks(self) -&gt; None:\n        canvas = self.query_one(\"#plot\", Canvas)\n        bottom_margin = self.query_one(\"#margin-bottom\", Canvas)\n        bottom_margin.reset()\n\n        x_ticks: Sequence[float]\n        if self._x_ticks is None:\n            x_ticks, x_labels = self.get_ticks_between(self._x_min, self._x_max)\n        else:\n            x_ticks = self._x_ticks\n            x_labels = self.get_labels_for_ticks(x_ticks)\n        for tick, label in zip(x_ticks, x_labels):\n            if tick &lt; self._x_min or tick &gt; self._x_max:\n                continue\n            align = TextAlign.CENTER\n            # only interested in the x-coordinate, set y to 0.0\n            x, _ = self.get_pixel_from_coordinate(tick, 0.0)\n            if tick == self._x_min:\n                x -= 1\n            elif tick == self._x_max:\n                align = TextAlign.RIGHT\n            for y, quad in [\n                # put ticks at top and bottom of scale rectangle\n                (0, (2, 0, 0, 0)),\n                (self._scale_rectangle.bottom, (0, 0, 2, 0)),\n            ]:\n                new_pixel = self.combine_quad_with_pixel(quad, canvas, x, y)\n                canvas.set_pixel(\n                    x,\n                    y,\n                    new_pixel,\n                    style=str(self.get_component_rich_style(\"plot--axis\")),\n                )\n            bottom_margin.write_text(\n                x + self.margin_left,\n                0,\n                f\"[{self.get_component_rich_style('plot--tick')}]{label}\",\n                align,\n            )\n\n    def _render_y_ticks(self) -&gt; None:\n        canvas = self.query_one(\"#plot\", Canvas)\n        left_margin = self.query_one(\"#margin-left\", Canvas)\n        left_margin.reset()\n\n        y_ticks: Sequence[float]\n        if self._y_ticks is None:\n            y_ticks, y_labels = self.get_ticks_between(self._y_min, self._y_max)\n        else:\n            y_ticks = self._y_ticks\n            y_labels = self.get_labels_for_ticks(y_ticks)\n        # truncate y-labels to the left margin width\n        y_labels = [label[: self.margin_left - 1] for label in y_labels]\n        align = TextAlign.RIGHT\n        for tick, label in zip(y_ticks, y_labels):\n            if tick &lt; self._y_min or tick &gt; self._y_max:\n                continue\n            # only interested in the y-coordinate, set x to 0.0\n            _, y = self.get_pixel_from_coordinate(0.0, tick)\n            if tick == self._y_min:\n                y += 1\n            for x, quad in [\n                # put ticks at left and right of scale rectangle\n                (0, (0, 0, 0, 2)),\n                (self._scale_rectangle.right, (0, 2, 0, 0)),\n            ]:\n                new_pixel = self.combine_quad_with_pixel(quad, canvas, x, y)\n                canvas.set_pixel(\n                    x,\n                    y,\n                    new_pixel,\n                    style=str(self.get_component_rich_style(\"plot--axis\")),\n                )\n            left_margin.write_text(\n                self.margin_left - 2,\n                y,\n                f\"[{self.get_component_rich_style('plot--tick')}]{label}\",\n                align,\n            )\n\n    def _render_x_label(self) -&gt; None:\n        canvas = self.query_one(\"#plot\", Canvas)\n        margin = self.query_one(\"#margin-bottom\", Canvas)\n        margin.write_text(\n            canvas.size.width // 2 + self.margin_left,\n            2,\n            f\"[{self.get_component_rich_style('plot--label')}]{self._x_label}\",\n            TextAlign.CENTER,\n        )\n\n    def _render_y_label(self) -&gt; None:\n        margin = self.query_one(\"#margin-top\", Canvas)\n        margin.write_text(\n            self.margin_left - 2,\n            0,\n            f\"[{self.get_component_rich_style('plot--label')}]{self._y_label}\",\n            TextAlign.CENTER,\n        )\n\n    def get_ticks_between(\n        self, min_: float, max_: float, max_ticks: int = 8\n    ) -&gt; tuple[list[float], list[str]]:\n        delta_x = max_ - min_\n        tick_spacing = delta_x / 5\n        power = floor(log10(tick_spacing))\n        approx_interval = tick_spacing / 10**power\n        intervals = np.array([1.0, 2.0, 5.0, 10.0])\n\n        idx = intervals.searchsorted(approx_interval)\n        interval = (intervals[idx - 1] if idx &gt; 0 else intervals[0]) * 10**power\n        if delta_x // interval &gt; max_ticks:\n            interval = intervals[idx] * 10**power\n        ticks = [\n            float(t)\n            for t in np.arange(\n                ceil(min_ / interval) * interval, max_ + interval / 2, interval\n            )\n        ]\n        decimals = -min(0, power)\n        tick_labels = self.get_labels_for_ticks(ticks, decimals)\n        return ticks, tick_labels\n\n    def get_labels_for_ticks(\n        self, ticks: Sequence[float], decimals: int | None = None\n    ) -&gt; list[str]:\n        \"\"\"Generate formatted labels for given tick values.\n\n        Args:\n            ticks: A list of tick values to be formatted.\n            decimals: The number of decimal places for formatting the tick values.\n\n        Returns:\n            A list of formatted tick labels as strings.\n        \"\"\"\n        if not ticks:\n            return []\n        if decimals is None:\n            if len(ticks) &gt;= 2:\n                power = floor(log10(ticks[1] - ticks[0]))\n            else:\n                power = 0\n            decimals = -min(0, power)\n        tick_labels = [f\"{tick:.{decimals}f}\" for tick in ticks]\n        return tick_labels\n\n    def combine_quad_with_pixel(\n        self, quad: tuple[int, int, int, int], canvas: Canvas, x: int, y: int\n    ) -&gt; str:\n        pixel = canvas.get_pixel(x, y)[0]\n        for current_quad, v in BOX_CHARACTERS.items():\n            if v == pixel:\n                break\n        new_quad = combine_quads(current_quad, quad)\n        return BOX_CHARACTERS[new_quad]\n\n    def get_pixel_from_coordinate(\n        self, x: FloatScalar, y: FloatScalar\n    ) -&gt; tuple[int, int]:\n        return map_coordinate_to_pixel(\n            x,\n            y,\n            self._x_min,\n            self._x_max,\n            self._y_min,\n            self._y_max,\n            region=self._scale_rectangle,\n        )\n\n    def get_hires_pixel_from_coordinate(\n        self, x: FloatScalar, y: FloatScalar\n    ) -&gt; tuple[FloatScalar, FloatScalar]:\n        return map_coordinate_to_hires_pixel(\n            x,\n            y,\n            self._x_min,\n            self._x_max,\n            self._y_min,\n            self._y_max,\n            region=self._scale_rectangle,\n        )\n\n    def get_coordinate_from_pixel(self, x: int, y: int) -&gt; tuple[float, float]:\n        return map_pixel_to_coordinate(\n            x,\n            y,\n            self._x_min,\n            self._x_max,\n            self._y_min,\n            self._y_max,\n            region=self._scale_rectangle,\n        )\n\n    def _zoom(self, event: MouseScrollDown | MouseScrollUp, factor: float) -&gt; None:\n        if not self._allow_pan_and_zoom:\n            return\n\n        if self.invert_mouse_wheel:\n            factor *= -1\n\n        if (offset := event.get_content_offset(self)) is not None:\n            widget, _ = self.screen.get_widget_at(event.screen_x, event.screen_y)\n            canvas = self.query_one(\"#plot\", Canvas)\n            if widget.id == \"margin-bottom\":\n                offset = event.screen_offset - self.screen.get_offset(canvas)\n            x, y = self.get_coordinate_from_pixel(offset.x, offset.y)\n            if widget.id in (\"plot\", \"margin-bottom\"):\n                self._auto_x_min = False\n                self._auto_x_max = False\n                self._x_min = (self._x_min + factor * x) / (1 + factor)\n                self._x_max = (self._x_max + factor * x) / (1 + factor)\n            if widget.id in (\"plot\", \"margin-left\"):\n                self._auto_y_min = False\n                self._auto_y_max = False\n                self._y_min = (self._y_min + factor * y) / (1 + factor)\n                self._y_max = (self._y_max + factor * y) / (1 + factor)\n            self.post_message(\n                self.ScaleChanged(\n                    self, self._x_min, self._x_max, self._y_min, self._y_max\n                )\n            )\n            self.refresh(layout=True)\n\n    @on(MouseScrollDown)\n    def zoom_in(self, event: MouseScrollDown) -&gt; None:\n        event.stop()\n        self._zoom(event, ZOOM_FACTOR)\n\n    @on(MouseScrollUp)\n    def zoom_out(self, event: MouseScrollUp) -&gt; None:\n        event.stop()\n        self._zoom(event, -ZOOM_FACTOR)\n\n    @on(MouseDown)\n    def start_dragging_legend(self, event: MouseDown) -&gt; None:\n        widget, _ = self.screen.get_widget_at(event.screen_x, event.screen_y)\n        if event.button == 1 and widget.id == \"legend\":\n            self._is_dragging_legend = True\n            widget.add_class(\"dragged\")\n            event.stop()\n\n    @on(MouseUp)\n    def stop_dragging_legend(self, event: MouseUp) -&gt; None:\n        if event.button == 1 and self._is_dragging_legend:\n            self._is_dragging_legend = False\n            self.query_one(\"#legend\").remove_class(\"dragged\")\n            event.stop()\n\n    @on(MouseMove)\n    def drag_with_mouse(self, event: MouseMove) -&gt; None:\n        if not self._allow_pan_and_zoom:\n            return\n        if event.button == 0:\n            # If no button is pressed, don't drag.\n            return\n\n        if self._is_dragging_legend:\n            self._drag_legend(event)\n        else:\n            self._pan_plot(event)\n\n    def _drag_legend(self, event: MouseMove) -&gt; None:\n        self._legend_relative_offset += event.delta\n        self._position_legend()\n        self.query_one(\"#legend\").refresh(layout=True)\n\n    def _pan_plot(self, event: MouseMove) -&gt; None:\n        x1, y1 = self.get_coordinate_from_pixel(1, 1)\n        x2, y2 = self.get_coordinate_from_pixel(2, 2)\n        dx, dy = x2 - x1, y1 - y2\n\n        assert event.widget is not None\n        if event.widget.id in (\"plot\", \"margin-bottom\"):\n            self._auto_x_min = False\n            self._auto_x_max = False\n            self._x_min -= dx * event.delta_x\n            self._x_max -= dx * event.delta_x\n        if event.widget.id in (\"plot\", \"margin-left\"):\n            self._auto_y_min = False\n            self._auto_y_max = False\n            self._y_min += dy * event.delta_y\n            self._y_max += dy * event.delta_y\n        self.post_message(\n            self.ScaleChanged(self, self._x_min, self._x_max, self._y_min, self._y_max)\n        )\n        self.refresh(layout=True)\n\n    def action_reset_scales(self) -&gt; None:\n        self.set_xlimits(self._user_x_min, self._user_x_max)\n        self.set_ylimits(self._user_y_min, self._user_y_max)\n        self.post_message(\n            self.ScaleChanged(self, self._x_min, self._x_max, self._y_min, self._y_max)\n        )\n        self.refresh()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.__init__","title":"<code>__init__(name=None, id=None, classes=None, *, allow_pan_and_zoom=True, invert_mouse_wheel=False, disabled=False)</code>","text":"<p>Initializes the plot widget with basic widget parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the widget.</p> <code>None</code> <code>id</code> <code>str | None</code> <p>The ID of the widget in the DOM.</p> <code>None</code> <code>classes</code> <code>str | None</code> <p>The CSS classes for the widget.</p> <code>None</code> <code>allow_pan_and_zoom</code> <code>bool</code> <p>Whether to allow panning and zooming the plot. Defaults to True.</p> <code>True</code> <code>invert_mouse_wheel</code> <code>bool</code> <p>When set to True the zooming direction is inverted when scrolling in and out of the widget. Defaults to False.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Whether the widget is disabled or not.</p> <code>False</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    id: str | None = None,\n    classes: str | None = None,\n    *,\n    allow_pan_and_zoom: bool = True,\n    invert_mouse_wheel: bool = False,\n    disabled: bool = False,\n) -&gt; None:\n    \"\"\"Initializes the plot widget with basic widget parameters.\n\n    Params:\n        name: The name of the widget.\n        id: The ID of the widget in the DOM.\n        classes: The CSS classes for the widget.\n        allow_pan_and_zoom: Whether to allow panning and zooming the plot.\n            Defaults to True.\n        invert_mouse_wheel: When set to True the zooming direction is inverted\n            when scrolling in and out of the widget. Defaults to False.\n        disabled: Whether the widget is disabled or not.\n    \"\"\"\n    super().__init__(\n        name=name,\n        id=id,\n        classes=classes,\n        disabled=disabled,\n    )\n    self._datasets = []\n    self._labels = []\n    self._v_lines: list[VLinePlot] = []\n    self._v_lines_labels: list[str | None] = []\n    self._allow_pan_and_zoom = allow_pan_and_zoom\n    self.invert_mouse_wheel = invert_mouse_wheel\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.add_v_line","title":"<code>add_v_line(x, line_style='white', label=None)</code>","text":"<p>Draw a vertical line on the plot.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate where the vertical line will be placed.</p> required <code>line_style</code> <code>str</code> <p>A string with the style of the line. Defaults to \"white\".</p> <code>'white'</code> <code>label</code> <code>str | None</code> <p>A string with the label for the line. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def add_v_line(\n    self, x: float, line_style: str = \"white\", label: str | None = None\n) -&gt; None:\n    \"\"\"Draw a vertical line on the plot.\n\n    Args:\n        x: The x-coordinate where the vertical line will be placed.\n        line_style: A string with the style of the line. Defaults to \"white\".\n        label: A string with the label for the line. Defaults to None.\n    \"\"\"\n    self._v_lines.append(VLinePlot(x=x, line_style=line_style))\n    self._v_lines_labels.append(label)\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.clear","title":"<code>clear()</code>","text":"<p>Clear the plot canvas.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the plot canvas.\"\"\"\n    self._datasets = []\n    self._labels = []\n    self._v_lines = []\n    self._v_lines_labels = []\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.get_labels_for_ticks","title":"<code>get_labels_for_ticks(ticks, decimals=None)</code>","text":"<p>Generate formatted labels for given tick values.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>Sequence[float]</code> <p>A list of tick values to be formatted.</p> required <code>decimals</code> <code>int | None</code> <p>The number of decimal places for formatting the tick values.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of formatted tick labels as strings.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def get_labels_for_ticks(\n    self, ticks: Sequence[float], decimals: int | None = None\n) -&gt; list[str]:\n    \"\"\"Generate formatted labels for given tick values.\n\n    Args:\n        ticks: A list of tick values to be formatted.\n        decimals: The number of decimal places for formatting the tick values.\n\n    Returns:\n        A list of formatted tick labels as strings.\n    \"\"\"\n    if not ticks:\n        return []\n    if decimals is None:\n        if len(ticks) &gt;= 2:\n            power = floor(log10(ticks[1] - ticks[0]))\n        else:\n            power = 0\n        decimals = -min(0, power)\n    tick_labels = [f\"{tick:.{decimals}f}\" for tick in ticks]\n    return tick_labels\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.plot","title":"<code>plot(x, y, line_style='white', hires_mode=None, label=None)</code>","text":"<p>Graph dataset using a line plot.</p> <p>If you supply hires_mode, the dataset will be plotted using one of the available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell characters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the horizontal axis.</p> required <code>y</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the vertical axis.</p> required <code>line_style</code> <code>str</code> <p>A string with the style of the line. Defaults to \"white\".</p> <code>'white'</code> <code>hires_mode</code> <code>HiResMode | None</code> <p>A HiResMode enum or None to plot with full-height blocks. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>A string with the label for the dataset. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def plot(\n    self,\n    x: ArrayLike,\n    y: ArrayLike,\n    line_style: str = \"white\",\n    hires_mode: HiResMode | None = None,\n    label: str | None = None,\n) -&gt; None:\n    \"\"\"Graph dataset using a line plot.\n\n    If you supply hires_mode, the dataset will be plotted using one of the\n    available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n    characters.\n\n    Args:\n        x: An ArrayLike with the data values for the horizontal axis.\n        y: An ArrayLike with the data values for the vertical axis.\n        line_style: A string with the style of the line. Defaults to\n            \"white\".\n        hires_mode: A HiResMode enum or None to plot with full-height\n            blocks. Defaults to None.\n        label: A string with the label for the dataset. Defaults to None.\n    \"\"\"\n    x, y = drop_nans_and_infs(np.array(x), np.array(y))\n    self._datasets.append(\n        LinePlot(\n            x=x,\n            y=y,\n            line_style=line_style,\n            hires_mode=hires_mode,\n        )\n    )\n    self._labels.append(label)\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.refresh","title":"<code>refresh(*regions, repaint=True, layout=False, recompose=False)</code>","text":"<p>Refresh the widget.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def refresh(\n    self,\n    *regions: Region,\n    repaint: bool = True,\n    layout: bool = False,\n    recompose: bool = False,\n) -&gt; Self:\n    \"\"\"Refresh the widget.\"\"\"\n    if layout is True:\n        self._needs_rerender = True\n    return super().refresh(\n        *regions, repaint=repaint, layout=layout, recompose=recompose\n    )\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.scatter","title":"<code>scatter(x, y, marker='o', marker_style='white', hires_mode=None, label=None)</code>","text":"<p>Graph dataset using a scatter plot.</p> <p>If you supply hires_mode, the dataset will be plotted using one of the available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell characters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the horizontal axis.</p> required <code>y</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the vertical axis.</p> required <code>marker</code> <code>str</code> <p>A string with the character to print as the marker.</p> <code>'o'</code> <code>marker_style</code> <code>str</code> <p>A string with the style of the marker. Defaults to \"white\".</p> <code>'white'</code> <code>hires_mode</code> <code>HiResMode | None</code> <p>A HiResMode enum or None to plot with the supplied marker. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>A string with the label for the dataset. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def scatter(\n    self,\n    x: ArrayLike,\n    y: ArrayLike,\n    marker: str = \"o\",\n    marker_style: str = \"white\",\n    hires_mode: HiResMode | None = None,\n    label: str | None = None,\n) -&gt; None:\n    \"\"\"Graph dataset using a scatter plot.\n\n    If you supply hires_mode, the dataset will be plotted using one of the\n    available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n    characters.\n\n    Args:\n        x: An ArrayLike with the data values for the horizontal axis.\n        y: An ArrayLike with the data values for the vertical axis.\n        marker: A string with the character to print as the marker.\n        marker_style: A string with the style of the marker. Defaults to\n            \"white\".\n        hires_mode: A HiResMode enum or None to plot with the supplied\n            marker. Defaults to None.\n        label: A string with the label for the dataset. Defaults to None.\n    \"\"\"\n    x, y = drop_nans_and_infs(np.array(x), np.array(y))\n    self._datasets.append(\n        ScatterPlot(\n            x=x,\n            y=y,\n            marker=marker,\n            marker_style=marker_style,\n            hires_mode=hires_mode,\n        )\n    )\n    self._labels.append(label or \"\")\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_xlabel","title":"<code>set_xlabel(label)</code>","text":"<p>Set a label for the x axis.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>A string with the label text.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_xlabel(self, label: str) -&gt; None:\n    \"\"\"Set a label for the x axis.\n\n    Args:\n        label: A string with the label text.\n    \"\"\"\n    self._x_label = label\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_xlimits","title":"<code>set_xlimits(xmin=None, xmax=None)</code>","text":"<p>Set the limits of the x axis.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float | None</code> <p>A float with the minimum x value or None for autoscaling. Defaults to None.</p> <code>None</code> <code>xmax</code> <code>float | None</code> <p>A float with the maximum x value or None for autoscaling. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_xlimits(self, xmin: float | None = None, xmax: float | None = None) -&gt; None:\n    \"\"\"Set the limits of the x axis.\n\n    Args:\n        xmin: A float with the minimum x value or None for autoscaling.\n            Defaults to None.\n        xmax: A float with the maximum x value or None for autoscaling.\n            Defaults to None.\n    \"\"\"\n    self._user_x_min = xmin\n    self._user_x_max = xmax\n    self._auto_x_min = xmin is None\n    self._auto_x_max = xmax is None\n    self._x_min = xmin if xmin is not None else 0.0\n    self._x_max = xmax if xmax is not None else 1.0\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_xticks","title":"<code>set_xticks(ticks=None)</code>","text":"<p>Set the x axis ticks.</p> <p>Use None for autoscaling, an empty list to hide the ticks.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>Sequence[float] | None</code> <p>An iterable with the tick values.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_xticks(self, ticks: Sequence[float] | None = None) -&gt; None:\n    \"\"\"Set the x axis ticks.\n\n    Use None for autoscaling, an empty list to hide the ticks.\n\n    Args:\n        ticks: An iterable with the tick values.\n    \"\"\"\n    self._x_ticks = ticks\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_ylabel","title":"<code>set_ylabel(label)</code>","text":"<p>Set a label for the y axis.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>A string with the label text.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_ylabel(self, label: str) -&gt; None:\n    \"\"\"Set a label for the y axis.\n\n    Args:\n        label: A string with the label text.\n    \"\"\"\n    self._y_label = label\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_ylimits","title":"<code>set_ylimits(ymin=None, ymax=None)</code>","text":"<p>Set the limits of the y axis.</p> <p>Parameters:</p> Name Type Description Default <code>ymin</code> <code>float | None</code> <p>A float with the minimum y value or None for autoscaling. Defaults to None.</p> <code>None</code> <code>ymax</code> <code>float | None</code> <p>A float with the maximum y value or None for autoscaling. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_ylimits(self, ymin: float | None = None, ymax: float | None = None) -&gt; None:\n    \"\"\"Set the limits of the y axis.\n\n    Args:\n        ymin: A float with the minimum y value or None for autoscaling.\n            Defaults to None.\n        ymax: A float with the maximum y value or None for autoscaling.\n            Defaults to None.\n    \"\"\"\n    self._user_y_min = ymin\n    self._user_y_max = ymax\n    self._auto_y_min = ymin is None\n    self._auto_y_max = ymax is None\n    self._y_min = ymin if ymin is not None else 0.0\n    self._y_max = ymax if ymax is not None else 1.0\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_yticks","title":"<code>set_yticks(ticks=None)</code>","text":"<p>Set the y axis ticks.</p> <p>Use None for autoscaling, an empty list to hide the ticks.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>Sequence[float] | None</code> <p>An iterable with the tick values.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_yticks(self, ticks: Sequence[float] | None = None) -&gt; None:\n    \"\"\"Set the y axis ticks.\n\n    Use None for autoscaling, an empty list to hide the ticks.\n\n    Args:\n        ticks: An iterable with the tick values.\n    \"\"\"\n    self._y_ticks = ticks\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.show_legend","title":"<code>show_legend(location=LegendLocation.TOPRIGHT, is_visible=True)</code>","text":"<p>Show or hide the legend for the datasets in the plot.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>A boolean indicating whether to show the legend. Defaults to True.</p> <code>True</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def show_legend(\n    self,\n    location: LegendLocation = LegendLocation.TOPRIGHT,\n    is_visible: bool = True,\n) -&gt; None:\n    \"\"\"Show or hide the legend for the datasets in the plot.\n\n    Args:\n        is_visible: A boolean indicating whether to show the legend.\n            Defaults to True.\n    \"\"\"\n    self.query_one(\"#legend\", Static).display = is_visible\n    if not is_visible:\n        return\n\n    self._position_legend()\n\n    legend_lines = []\n    if isinstance(location, LegendLocation):\n        self._legend_location = location\n    else:\n        raise TypeError(\n            f\"Expected LegendLocation, got {type(location).__name__} instead.\"\n        )\n\n    for label, dataset in zip(self._labels, self._datasets):\n        if label is not None:\n            if isinstance(dataset, ScatterPlot):\n                marker = (\n                    dataset.marker\n                    if dataset.hires_mode is None\n                    else LEGEND_MARKER[dataset.hires_mode]\n                ).center(3)\n                style = dataset.marker_style\n            elif isinstance(dataset, LinePlot):\n                marker = LEGEND_LINE[dataset.hires_mode]\n                style = dataset.line_style\n            else:\n                # unsupported dataset type\n                continue\n            text = Text(marker)\n            text.stylize(style)\n            text.append(f\" {label}\")\n            legend_lines.append(text.markup)\n\n    for label, vline in zip(self._v_lines_labels, self._v_lines):\n        if label is not None:\n            marker = \"\u2502\".center(3)\n            style = vline.line_style\n            text = Text(marker)\n            text.stylize(style)\n            text.append(f\" {label}\")\n            legend_lines.append(text.markup)\n\n    self.query_one(\"#legend\", Static).update(\n        Text.from_markup(\"\\n\".join(legend_lines))\n    )\n</code></pre>"}]}