{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"A native plotting widget for Textual apps","text":"<p>Textual is an excellent Python framework for building applications in the terminal, or on the web. This library provides a plot widget which your app can use to plot all kinds of quantitative data. So, no pie charts, sorry. The widget support scatter plots and line plots, and can also draw using high-resolution characters like unicode half blocks, quadrants and 8-dot Braille characters. It may still be apparent that these are drawn using characters that take up a full block in the terminal, especially when plot series overlap. However, the use of these characters can reduce the line thickness and improve the resolution tremendously.</p>"},{"location":"#screenshots","title":"Screenshots","text":"<p>The daytime spectrum dataset shows the visible-light spectrum recorded by an Ocean Optics USB2000+ spectrometer using the DeadSea Optics software. It was taken in the morning while the detector was facing my office window.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Line plots</li> <li>Scatter plots</li> <li>Automatic scaling and tick placement at nice intervals (1, 2, 5, etc.)</li> <li>Axes labels</li> <li>High-resolution modes using unicode half blocks (1x2), quadrants (2x2) and braille (2x8) characters</li> <li>Mouse support for zooming (mouse scrolling) and panning (mouse dragging)</li> <li>Horizontal- or vertical-only zooming and panning when the mouse cursor is in the plot margins</li> </ul>"},{"location":"#running-the-demo-installation","title":"Running the demo / installation","text":"<p>Using uv:</p> <pre><code>uvx textual-plot\n</code></pre> <p>Using pipx:</p> <pre><code>pipx run textual-plot\n</code></pre> <p>Install the package with either</p> <pre><code>uv tool install textual-plot\n</code></pre> <p>or</p> <pre><code>pipx install textual-plot\n</code></pre> <p>Alternatively, install the package with <code>pip</code> (please, use virtual environments) and run the demo:</p> <pre><code>pip install textual-plot\n</code></pre> <p>In all cases, you can run the demo with</p> <pre><code>textual-plot\n</code></pre>"},{"location":"#tutorial","title":"Tutorial","text":"<p>A minimal example is shown below: </p> <pre><code>from textual.app import App, ComposeResult\n\nfrom textual_plot import PlotWidget\n\n\nclass MinimalApp(App[None]):\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        plot = self.query_one(PlotWidget)\n        plot.plot(x=[0, 1, 2, 3, 4], y=[0, 1, 4, 9, 16])\n\n\nMinimalApp().run()\n</code></pre> <p>You include a <code>PlotWidget</code> in your compose method and after your UI has finished composing, you can start plotting data. The <code>plot()</code> method takes <code>x</code> and <code>y</code> data which should be array-like. It can be lists, or NumPy arrays, or really anything that can be turned into a NumPy array which is what's used internally. The <code>plot()</code> method further accepts a <code>line_style</code> argument which accepts Textual styles like <code>\"white\"</code>, <code>\"red on blue3\"</code>, etc. For standard low-resolution plots, it does not make much sense to specify a background color since the text character used for plotting is a full block filling an entire cell.</p>"},{"location":"#high-resolution-plotting","title":"High-resolution plotting","text":"<p>The plot widget supports high-resolution plotting where the character does not take up the full cell:</p> <p></p> <pre><code>from textual.app import App, ComposeResult\n\nfrom textual_plot import HiResMode, PlotWidget\n\n\nclass MinimalApp(App[None]):\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        plot = self.query_one(PlotWidget)\n        plot.plot(\n            x=[0, 1, 2, 3, 4],\n            y=[0, 1, 4, 9, 16],\n            hires_mode=HiResMode.BRAILLE,\n            line_style=\"bright_yellow on blue3\",\n        )\n\n\nMinimalApp().run()\n</code></pre> <p>Admittedly, you'll be mostly plotting with foreground colors only. The plot widget supports four high-resolution modes: <code>Hires.BRAILLE</code> (2x8), <code>HiRes.HALFBLOCK</code> (1x2) and <code>HiRes.QUADRANT</code> (2x2) where the size between brackets is the number of 'pixels' inside a single cell.</p>"},{"location":"#scatter-plots","title":"Scatter plots","text":"<p>To create scatter plots, use the <code>scatter()</code> method, which accepts a <code>marker</code> argument which can be any unicode character (as long as it is one cell wide, which excludes many emoji characters and non-Western scripts): </p> <pre><code>import numpy as np\nfrom textual.app import App, ComposeResult\n\nfrom textual_plot import PlotWidget\n\n\nclass MinimalApp(App[None]):\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        rng = np.random.default_rng(seed=4)\n        plot = self.query_one(PlotWidget)\n\n        x = np.linspace(0, 10, 21)\n        y = 0.2 * x - 1 + rng.normal(loc=0.0, scale=0.2, size=len(x))\n        plot.scatter(x, y, marker=\"\u29bf\")\n\n\nMinimalApp().run()\n</code></pre>"},{"location":"#the-full-demo-code","title":"The full demo code","text":"<p>Finally, the code of the demo is given below, showing how you can handle multiple plots and updating 'live' data:</p> <pre><code>from __future__ import annotations\n\nimport importlib.resources\nimport itertools\n\nimport numpy as np\nfrom textual import on\nfrom textual.app import App, ComposeResult\nfrom textual.binding import Binding\nfrom textual.containers import Container, Grid\nfrom textual.widgets import Footer, Header, Label, TabbedContent, TabPane\nfrom textual_hires_canvas import HiResMode\n\nfrom textual_plot import DurationFormatter, NumericAxisFormatter, PlotWidget\n\n\nclass SpectrumPlot(Container):\n    BINDINGS = [(\"m\", \"cycle_modes\", \"Cycle Modes\")]\n\n    _modes = itertools.cycle(\n        [HiResMode.QUADRANT, HiResMode.BRAILLE, None, HiResMode.HALFBLOCK]\n    )\n    mode = next(_modes)\n\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        # Read CSV data included with this package\n        self.spectrum_csv = importlib.resources.read_text(\n            \"textual_plot.resources\", \"morning-spectrum.csv\"\n        ).splitlines()\n\n        # plot the spectrum and set ymin limit once\n        self.plot_spectrum()\n        self.query_one(PlotWidget).set_ylimits(ymin=0)\n\n    def plot_spectrum(self) -&gt; None:\n        x, y = np.genfromtxt(\n            self.spectrum_csv,\n            delimiter=\",\",\n            names=True,\n            unpack=True,\n        )\n\n        plot = self.query_one(PlotWidget)\n        plot.clear()\n        plot.plot(x, y, hires_mode=self.mode)\n        plot.add_v_line(380, \"dark_red\", \"IR boundary\")\n        plot.add_v_line(750, \"purple4\", \"UV boundary\")\n        plot.set_xlabel(\"Wavelength (nm)\")\n        plot.set_ylabel(\"Intensity\")\n        plot.show_legend()\n\n    def action_cycle_modes(self) -&gt; None:\n        self.mode = next(self._modes)\n        self.plot_spectrum()\n\n\nclass SinePlot(Container):\n    BINDINGS = [\n        (\"c\", \"clear\", \"Clear\"),\n        (\"f\", \"toggle_formatter\", \"Toggle Formatter\"),\n        (\"m\", \"cycle_multiplier\", \"Cycle Multiplier\"),\n    ]\n\n    # Update frequency in Hz (updates per second)\n    UPDATE_FREQUENCY: float = 24.0\n\n    N: int = 1\n    use_duration_formatter: bool = False\n\n    # Available multipliers\n    _multipliers = itertools.cycle([1, 10, 100, 1000, 10_000, 100_000])\n    x_multiplier: float = next(_multipliers)\n\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        self._timer = self.set_interval(\n            1 / self.UPDATE_FREQUENCY, self.plot_moving_sines, pause=True\n        )\n        # Set initial x-axis label\n        self._update_x_label()\n\n    def on_show(self) -&gt; None:\n        self._timer.resume()\n\n    def on_hide(self) -&gt; None:\n        self._timer.pause()\n\n    def action_clear(self) -&gt; None:\n        self.N = 1\n\n    def action_toggle_formatter(self) -&gt; None:\n        \"\"\"Toggle between NumericAxisFormatter and DurationFormatter.\"\"\"\n        self.use_duration_formatter = not self.use_duration_formatter\n        plot = self.query_one(PlotWidget)\n\n        if self.use_duration_formatter:\n            plot.set_x_formatter(DurationFormatter())\n        else:\n            plot.set_x_formatter(NumericAxisFormatter())\n\n        # Update x-axis label\n        self._update_x_label()\n\n        # Force a replot with current data\n        self.plot_moving_sines()\n\n    def action_cycle_multiplier(self) -&gt; None:\n        \"\"\"Cycle through different multipliers.\"\"\"\n        self.x_multiplier = next(self._multipliers)\n\n        # Update x-axis label\n        self._update_x_label()\n\n        # Force a replot with current data\n        self.plot_moving_sines()\n\n    def _update_x_label(self) -&gt; None:\n        \"\"\"Update the x-axis label with formatter name and multiplier.\"\"\"\n        plot = self.query_one(PlotWidget)\n        formatter_name = plot._x_formatter.__class__.__name__\n        plot.set_xlabel(f\"{formatter_name} (multiplier: {self.x_multiplier})\")\n\n    def plot_moving_sines(self) -&gt; None:\n        plot = self.query_one(PlotWidget)\n        plot.clear()\n\n        # Generate x values: after N updates at UPDATE_FREQUENCY Hz,\n        # we have N data points spanning N/UPDATE_FREQUENCY seconds\n        # So x ranges from 0 to N/UPDATE_FREQUENCY with N points\n        x = np.linspace(0, self.N / self.UPDATE_FREQUENCY, self.N + 1)\n        x_plot = x * self.x_multiplier\n\n        plot.plot(\n            x=x_plot,\n            y=10 + 10 * np.sin(x + 3),\n            line_style=\"yellow\",\n            hires_mode=HiResMode.BRAILLE,\n        )\n        plot.plot(\n            x=x_plot,\n            y=10 + 10 * np.sin(x + 2),\n            line_style=\"green\",\n            hires_mode=HiResMode.QUADRANT,\n        )\n        plot.plot(\n            x=x_plot,\n            y=10 + 10 * np.sin(x + 1),\n            line_style=\"red3\",\n            hires_mode=HiResMode.HALFBLOCK,\n        )\n        plot.plot(\n            x=x_plot,\n            y=10 + 10 * np.sin(x),\n            line_style=\"blue\",\n            hires_mode=None,\n        )\n\n        plot.set_ylimits(0, 20)\n        self.N += 1\n\n\nclass MultiPlot(Grid):\n    BINDINGS = [Binding(\"r\", \"reset_scales\", \"Reset scales\", priority=True)]\n\n    DEFAULT_CSS = \"\"\"\n        MultiPlot {\n            grid-size: 2 4;\n            grid-rows: auto 1fr;\n\n            Label {\n                text-align: center;\n                text-style: bold;\n                padding: 1 2 0 2;\n                width: 100%;\n            }\n        }\n    \"\"\"\n\n    def compose(self) -&gt; ComposeResult:\n        yield Label(\"f(x) = x\")\n        yield Label(\"f(x) = x ** 2\")\n        yield PlotWidget(id=\"x\")\n        yield PlotWidget(id=\"x-squared\")\n        yield Label(\"f(x) = 1 / |1 + x|\")\n        yield Label(\"f(x) = sqrt(x)\")\n        yield PlotWidget(id=\"one-over-x\")\n        yield PlotWidget(id=\"sqrt-x\")\n\n    def on_mount(self) -&gt; None:\n        for plot in self.query(PlotWidget):\n            plot.margin_left = 8\n            plot.margin_top = 0\n            plot.margin_bottom = 1\n        self.plot()\n\n    def plot(self) -&gt; None:\n        plot = self.query_one(\"#x\", PlotWidget)\n        x = np.linspace(plot._x_min, plot._x_max, 101)\n        plot.clear()\n        plot.plot(x, x, hires_mode=HiResMode.BRAILLE)\n\n        plot = self.query_one(\"#x-squared\", PlotWidget)\n        plot.clear()\n        plot.plot(x, x**2, hires_mode=HiResMode.BRAILLE)\n\n        plot = self.query_one(\"#one-over-x\", PlotWidget)\n        plot.clear()\n        plot.plot(x, 1 / abs(1 + x), hires_mode=HiResMode.BRAILLE)\n\n        plot = self.query_one(\"#sqrt-x\", PlotWidget)\n        plot.clear()\n        plot.plot(x, np.sqrt(x), hires_mode=HiResMode.BRAILLE)\n\n    @on(PlotWidget.ScaleChanged)\n    def adjust_scales(self, event: PlotWidget.ScaleChanged) -&gt; None:\n        for plot in self.query(PlotWidget):\n            plot.set_xlimits(event.x_min, event.x_max)\n            plot.set_ylimits()\n        self.plot()\n\n    def action_reset_scales(self) -&gt; None:\n        for plot in self.query(PlotWidget):\n            plot.set_xlimits(0.0, 1.0)\n            plot.set_ylimits()\n        self.plot()\n\n\nclass ErrorBarPlot(Container):\n    BINDINGS = [\n        (\"n\", \"new_data\", \"New data\"),\n        (\"m\", \"cycle_marker\", \"Marker\"),\n        (\"h\", \"cycle_hires_mode\", \"HiRes\"),\n    ]\n\n    N = 100\n    _marker = itertools.cycle([\"\", \"o\"])\n    marker = next(_marker)\n    _hires_mode = itertools.cycle([None, HiResMode.BRAILLE])\n    hires_mode = next(_hires_mode)\n\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        self.action_new_data()\n        plot = self.query_one(PlotWidget)\n        plot.set_xlimits(-5, 5)\n        plot.set_ylimits(-5, 5)\n\n    def action_new_data(self) -&gt; None:\n        self.x = np.random.normal(0, 5.0, self.N)\n        self.y = np.random.normal(0, 5.0, self.N)\n        self.xerr = np.random.lognormal(-2, 0.5, self.N)\n        self.yerr = np.random.lognormal(-2, 0.5, self.N)\n        self.plot()\n\n    def plot(self) -&gt; None:\n        plot = self.query_one(PlotWidget)\n        plot.clear()\n        plot.errorbar(\n            self.x,\n            self.y,\n            self.xerr,\n            self.yerr,\n            marker=self.marker,\n            hires_mode=self.hires_mode,\n            label=\"Random data\",\n        )\n        plot.show_legend()\n\n    def action_cycle_marker(self) -&gt; None:\n        self.marker = next(self._marker)\n        self.plot()\n\n    def action_cycle_hires_mode(self) -&gt; None:\n        self.hires_mode = next(self._hires_mode)\n        self.plot()\n\n\nclass BarPlot(Container):\n    BINDINGS = [(\"h\", \"cycle_hires_mode\", \"HiRes\")]\n\n    _hires_mode = itertools.cycle([None, HiResMode.BRAILLE])\n    hires_mode = next(_hires_mode)\n\n    def compose(self) -&gt; ComposeResult:\n        yield PlotWidget()\n\n    def on_mount(self) -&gt; None:\n        self.plot()\n\n    def plot(self) -&gt; None:\n        plot = self.query_one(PlotWidget)\n        plot.clear()\n\n        y = [10.2, 8.3, 7.5, 9.1, 9]\n        styles = [\"red\", \"blue\", \"green\", \"white\", \"yellow\"]\n        x = styles\n        plot.bar(\n            x,\n            y,\n            bar_style=styles,\n            width=0.8,\n            label=\"Fancy bars\",\n            hires_mode=self.hires_mode,\n        )\n        plot.show_legend()\n\n    def action_cycle_hires_mode(self) -&gt; None:\n        self.hires_mode = next(self._hires_mode)\n        self.plot()\n\n\nclass DemoApp(App[None]):\n    AUTO_FOCUS = \"SinePlot &gt; PlotWidget\"\n\n    CSS = \"\"\"\n        PlotWidget {\n            margin-right: 2;\n            margin-bottom: 1;\n        }\n    \"\"\"\n\n    def compose(self) -&gt; ComposeResult:\n        yield Header()\n        yield Footer()\n        with TabbedContent():\n            with TabPane(\"Moving sines\", id=\"sines\"):\n                yield SinePlot()\n            with TabPane(\"Daytime spectrum\", id=\"spectrum\"):\n                yield SpectrumPlot()\n            with TabPane(\"Multiplot\", id=\"multiplot\"):\n                yield MultiPlot()\n            with TabPane(\"Errorbars\", id=\"errorbars\"):\n                yield ErrorBarPlot()\n            with TabPane(\"Bar plot\", id=\"barplot\"):\n                yield BarPlot()\n\n    def on_mount(self) -&gt; None:\n        self.theme = \"tokyo-night\"\n\n\ndef main() -&gt; None:\n    app = DemoApp()\n    app.run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#list-of-important-plot-widget-methods","title":"List of important plot widget methods","text":"<ul> <li><code>clear()</code>: clear the plot.</li> <li><code>plot(x, y, line_style, hires_mode, label)</code>: plot a dataset with a line using the specified linestyle and high-resolution mode.</li> <li><code>scatter(x, y, marker, marker_style, hires_mode, label)</code>: plot a dataset with markers using the specified marker, marker style and high-resolution mode.</li> <li><code>errorbar(x, y, xerr, yerr, marker, marker_style, hires_mode, label)</code>: plot a dataset with error bars,</li> <li><code>bar(x, y, width, bar_style, hires_mode, label)</code>: create a bar plot with quantitative or categorical x values,</li> <li><code>set_xlimits(xmin, xmax)</code>: set the x-axis limits. <code>None</code> means autoscale.</li> <li><code>set_ylimits(xmin, xmax)</code>: set the y-axis limits. <code>None</code> means autoscale.</li> <li><code>set_xticks(ticks)</code>: manually specify x-axis tick locations.</li> <li><code>set_yticks(ticks)</code>: manually specify y-axis tick locations.</li> <li><code>set_xlabel(label)</code>: set the x-axis label.</li> <li><code>set_ylabel(label)</code>: set the y-axis label.</li> <li><code>show_legend(location, is_visible)</code>: show or hide the plot legend.</li> </ul> <p>Various other methods exist, please see the reference.</p>"},{"location":"#alternatives","title":"Alternatives","text":"<p>Textual-plotext uses the plotext library which has more features than this library. However, it does not support interactive zooming or panning and the tick placement isn't as nice since it simply divides up the axes range into a fixed number of intervals giving values like 0, 123.4, 246.8, etc. The plotext library hasn't been updated since September, 2024 and hadn't seen significant updates since December, 2023. The author is working on a new version, a full rewrite, since at least October 2023. If you're looking for a library to use for your Textual application, this is it.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>We'll work on adding some features like datetime axes, and some quality-of-life improvements like even tick spacing. This will (probably) not turn into a general do-it-all plotting library. We focus first on handling quantitative data in the context of physics experiments. If you'd like to see features added, do let us know. And if a PR is of good quality and is a good fit for the API, we'd love to handle more use cases beyond physics. And who knows, maybe this will turn into a general plotting library!</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#textual_plot.HiResMode","title":"<code>HiResMode</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>.venv/lib/python3.10/site-packages/textual_hires_canvas/hires.py</code> <pre><code>class HiResMode(enum.Enum):\n    HALFBLOCK = enum.auto()\n    QUADRANT = enum.auto()\n    BRAILLE = enum.auto()\n</code></pre>"},{"location":"reference/#textual_plot.LegendLocation","title":"<code>LegendLocation</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enum to specify the location of the legend in the plot widget.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>class LegendLocation(enum.Enum):\n    \"\"\"An enum to specify the location of the legend in the plot widget.\"\"\"\n\n    TOPLEFT = enum.auto()\n    TOPRIGHT = enum.auto()\n    BOTTOMLEFT = enum.auto()\n    BOTTOMRIGHT = enum.auto()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget","title":"<code>PlotWidget</code>","text":"<p>               Bases: <code>Widget</code></p> <p>A plot widget for Textual apps.</p> <p>This widget supports high-resolution line and scatter plots, has nice ticks at 1, 2, 5, 10, 20, 50, etc. intervals and supports zooming and panning with your pointer device.</p> <p>The following component classes can be used to style the widget:</p> Class Description <code>plot--axis</code> Style of the axes (may be used to change the color). <code>plot--tick</code> Style of the tick labels along the axes. <code>plot--label</code> Style of axis labels. Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>class PlotWidget(Widget, can_focus=True):\n    \"\"\"A plot widget for Textual apps.\n\n    This widget supports high-resolution line and scatter plots, has nice ticks\n    at 1, 2, 5, 10, 20, 50, etc. intervals and supports zooming and panning with\n    your pointer device.\n\n    The following component classes can be used to style the widget:\n\n    | Class | Description |\n    | :- | :- |\n    | `plot--axis` | Style of the axes (may be used to change the color). |\n    | `plot--tick` | Style of the tick labels along the axes. |\n    | `plot--label` | Style of axis labels. |\n    \"\"\"\n\n    @dataclass\n    class ScaleChanged(Message):\n        \"\"\"Message posted when the plot scale (axis limits) changes.\n\n        Attributes:\n            plot: The PlotWidget instance that posted the message.\n            x_min: Minimum value of the x-axis after the change.\n            x_max: Maximum value of the x-axis after the change.\n            y_min: Minimum value of the y-axis after the change.\n            y_max: Maximum value of the y-axis after the change.\n        \"\"\"\n\n        plot: \"PlotWidget\"\n        x_min: float\n        x_max: float\n        y_min: float\n        y_max: float\n\n    COMPONENT_CLASSES = {\"plot--axis\", \"plot--tick\", \"plot--label\"}\n\n    DEFAULT_CSS = \"\"\"\n        PlotWidget {\n            layers: plot legend;\n\n            &amp;:focus &gt; .plot--axis {\n                color: $primary;\n            }\n\n            &amp; &gt; .plot--axis {\n                color: $secondary;\n            }\n\n            &amp; &gt; .plot--tick {\n                color: $secondary;\n                text-style: bold;\n            }\n\n            &amp; &gt; .plot--label {\n                color: $primary;\n                text-style: bold italic;\n            }\n\n            Grid {\n                layer: plot;\n                grid-size: 2 3;\n\n                #margin-top, #margin-bottom {\n                    column-span: 2;\n                }\n            }\n\n            #legend {\n              layer: legend;\n              width: auto;\n              border: solid white;\n              display: none;\n\n              &amp;.dragged {\n                border: heavy yellow;\n              }\n            }\n        }\n    \"\"\"\n\n    ZOOM_GROUP = Binding.Group(\"Zoom\")\n    PAN_GROUP = Binding.Group(\"Pan\")\n    BINDINGS = [\n        Binding(\"+\", \"zoom_in\", \"Zoom in\", group=ZOOM_GROUP),\n        Binding(\"-\", \"zoom_out\", \"Zoom out\", group=ZOOM_GROUP),\n        Binding(\n            \"ctrl+equals_sign\", \"zoom_x_in\", \"Zoom X in\", group=ZOOM_GROUP, show=False\n        ),\n        Binding(\"ctrl+minus\", \"zoom_x_out\", \"Zoom X out\", group=ZOOM_GROUP, show=False),\n        Binding(\n            \"ctrl+shift+equals_sign\",\n            \"zoom_y_in\",\n            \"Zoom Y in\",\n            group=ZOOM_GROUP,\n            show=False,\n        ),\n        Binding(\n            \"ctrl+shift+minus\", \"zoom_y_out\", \"Zoom Y out\", group=ZOOM_GROUP, show=False\n        ),\n        Binding(\"left\", \"pan_left\", \"Pan left\", group=PAN_GROUP),\n        Binding(\"right\", \"pan_right\", \"Pan right\", group=PAN_GROUP),\n        Binding(\"up\", \"pan_up\", \"Pan up\", group=PAN_GROUP),\n        Binding(\"down\", \"pan_down\", \"Pan down\", group=PAN_GROUP),\n        (\"r\", \"reset_scales\", \"Reset scales\"),\n    ]\n\n    margin_top = reactive(2)\n    margin_bottom = reactive(3)\n    margin_left = reactive(10)\n\n    MOUSE_ZOOM_FACTOR: float = 0.05\n    KEYBOARD_ZOOM_FACTOR: float = 0.15\n    KEYBOARD_PAN_FACTOR: float = 2.0\n\n    _datasets: list[DataSet]\n    _labels: list[str | None]\n\n    _user_x_min: float | None = None\n    _user_x_max: float | None = None\n    _user_y_min: float | None = None\n    _user_y_max: float | None = None\n    _auto_x_min: bool = True\n    _auto_x_max: bool = True\n    _auto_y_min: bool = True\n    _auto_y_max: bool = True\n    _x_min: float = 0.0\n    _x_max: float = 1.0\n    _y_min: float = 0.0\n    _y_max: float = 1.0\n\n    _x_ticks: Sequence[float] | None = None\n    _y_ticks: Sequence[float] | None = None\n    _x_formatter: AxisFormatter\n    _y_formatter: AxisFormatter\n\n    _scale_rectangle: Region = Region(0, 0, 0, 0)\n    _legend_location: LegendLocation = LegendLocation.TOPRIGHT\n    _legend_relative_offset: Offset = Offset(0, 0)\n\n    _x_label: str = \"\"\n    _y_label: str = \"\"\n\n    _allow_pan_and_zoom: bool = True\n    _is_dragging_legend: bool = False\n    _needs_rerender: bool = False\n\n    def __init__(\n        self,\n        name: str | None = None,\n        id: str | None = None,\n        classes: str | None = None,\n        *,\n        allow_pan_and_zoom: bool = True,\n        invert_mouse_wheel: bool = False,\n        disabled: bool = False,\n    ) -&gt; None:\n        \"\"\"Initializes the plot widget with basic widget parameters.\n\n        Params:\n            name: The name of the widget.\n            id: The ID of the widget in the DOM.\n            classes: The CSS classes for the widget.\n            allow_pan_and_zoom: Whether to allow panning and zooming the plot.\n                Defaults to True.\n            invert_mouse_wheel: When set to True the zooming direction is inverted\n                when scrolling in and out of the widget. Defaults to False.\n            disabled: Whether the widget is disabled or not.\n        \"\"\"\n        super().__init__(\n            name=name,\n            id=id,\n            classes=classes,\n            disabled=disabled,\n        )\n        self._datasets = []\n        self._labels = []\n        self._v_lines: list[VLinePlot] = []\n        self._v_lines_labels: list[str | None] = []\n        self._allow_pan_and_zoom = allow_pan_and_zoom\n        self.invert_mouse_wheel = invert_mouse_wheel\n        self._x_formatter = NumericAxisFormatter()\n        self._y_formatter = NumericAxisFormatter()\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compose the child widgets of the PlotWidget.\n\n        Returns:\n            An iterable of child widgets including the plot canvas, margins, and legend.\n        \"\"\"\n        with Grid():\n            yield Canvas(1, 1, id=\"margin-top\")\n            yield Canvas(1, 1, id=\"margin-left\")\n            yield Canvas(1, 1, id=\"plot\")\n            yield Canvas(1, 1, id=\"margin-bottom\")\n        yield Legend(id=\"legend\")\n\n    def on_mount(self) -&gt; None:\n        \"\"\"Initialize the plot widget when mounted to the DOM.\"\"\"\n        self._update_margin_sizes()\n        self.set_xlimits(None, None)\n        self.set_ylimits(None, None)\n        self.clear()\n\n    def notify_style_update(self) -&gt; None:\n        \"\"\"Called when styles update (e.g., theme change). Rerender the plot.\"\"\"\n        self.refresh(layout=True)\n\n    def _on_canvas_resize(self, event: Canvas.Resize) -&gt; None:\n        \"\"\"Handle canvas resize events to update the plot scale rectangle.\n\n        Args:\n            event: The canvas resize event containing the new size.\n        \"\"\"\n        if event.canvas.id == \"plot\":\n            # The scale rectangle falls just inside the axis rectangle\n            self._scale_rectangle = Region(\n                1, 1, event.size.width - 2, event.size.height - 2\n            )\n        event.canvas.reset(size=event.size)\n        self._position_legend()\n        self.refresh(layout=True)\n\n    def watch_margin_top(self) -&gt; None:\n        \"\"\"React to changes in the top margin reactive attribute.\"\"\"\n        self._update_margin_sizes()\n\n    def watch_margin_bottom(self) -&gt; None:\n        \"\"\"React to changes in the bottom margin reactive attribute.\"\"\"\n        self._update_margin_sizes()\n\n    def watch_margin_left(self) -&gt; None:\n        \"\"\"React to changes in the left margin reactive attribute.\"\"\"\n        self._update_margin_sizes()\n\n    def _update_margin_sizes(self) -&gt; None:\n        \"\"\"Update grid layout taking plot margins into account.\"\"\"\n        grid = self.query_one(Grid)\n        grid.styles.grid_columns = f\"{self.margin_left} 1fr\"\n        grid.styles.grid_rows = f\"{self.margin_top} 1fr {self.margin_bottom}\"\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear the plot canvas.\"\"\"\n        self._datasets = []\n        self._labels = []\n        self._v_lines = []\n        self._v_lines_labels = []\n        self.refresh(layout=True)\n\n    def plot(\n        self,\n        x: ArrayLike,\n        y: ArrayLike,\n        line_style: str = \"white\",\n        hires_mode: HiResMode | None = None,\n        label: str | None = None,\n    ) -&gt; None:\n        \"\"\"Graph dataset using a line plot.\n\n        If you supply hires_mode, the dataset will be plotted using one of the\n        available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n        characters.\n\n        Args:\n            x: An ArrayLike with the data values for the horizontal axis.\n            y: An ArrayLike with the data values for the vertical axis.\n            line_style: A string with the style of the line. Defaults to\n                \"white\".\n            hires_mode: A HiResMode enum or None to plot with full-height\n                blocks. Defaults to None.\n            label: A string with the label for the dataset. Defaults to None.\n        \"\"\"\n        x, y = drop_nans_and_infs(np.array(x), np.array(y))\n        self._datasets.append(\n            LinePlot(\n                x=x,\n                y=y,\n                line_style=line_style,\n                hires_mode=hires_mode,\n            )\n        )\n        self._labels.append(label)\n        self.refresh(layout=True)\n\n    def scatter(\n        self,\n        x: ArrayLike,\n        y: ArrayLike,\n        marker: str = \"o\",\n        marker_style: str = \"white\",\n        hires_mode: HiResMode | None = None,\n        label: str | None = None,\n    ) -&gt; None:\n        \"\"\"Graph dataset using a scatter plot.\n\n        If you supply hires_mode, the dataset will be plotted using one of the\n        available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n        characters.\n\n        Args:\n            x: An ArrayLike with the data values for the horizontal axis.\n            y: An ArrayLike with the data values for the vertical axis.\n            marker: A string with the character to print as the marker.\n            marker_style: A string with the style of the marker. Defaults to\n                \"white\".\n            hires_mode: A HiResMode enum or None to plot with the supplied\n                marker. Defaults to None.\n            label: A string with the label for the dataset. Defaults to None.\n        \"\"\"\n        x, y = drop_nans_and_infs(np.array(x), np.array(y))\n        self._datasets.append(\n            ScatterPlot(\n                x=x,\n                y=y,\n                marker=marker,\n                marker_style=marker_style,\n                hires_mode=hires_mode,\n            )\n        )\n        self._labels.append(label)\n        self.refresh(layout=True)\n\n    def errorbar(\n        self,\n        x: ArrayLike,\n        y: ArrayLike,\n        xerr: ArrayLike | None = None,\n        yerr: ArrayLike | None = None,\n        marker: str = \"\",\n        marker_style: str = \"white\",\n        hires_mode: HiResMode | None = None,\n        label: str | None = None,\n    ) -&gt; None:\n        \"\"\"Graph dataset using an error bar plot.\n\n        Error bars are rendered to half-cell resolution. If the error bars\n        become very small and no marker is specified, a dot is rendered at the\n        location of the data point. The markers are rendered last so that error\n        bars never obscure the data points.\n\n        If you supply hires_mode, the data points will be plotted using one of\n        the available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n        characters.\n\n        Args:\n            x: An ArrayLike with the data values for the horizontal axis.\n            y: An ArrayLike with the data values for the vertical axis.\n            xerr: An ArrayLike with the error values for the horizontal axis,\n                or None for no x errors. Defaults to None.\n            yerr: An ArrayLike with the error values for the vertical axis,\n                or None for no y errors. Defaults to None.\n            marker: A string with the character to print as the marker.\n            marker_style: A string with the style of the marker. Defaults to\n                \"white\".\n            hires_mode: A HiResMode enum or None to plot with the supplied\n                marker. Defaults to None.\n            label: A string with the label for the dataset. Defaults to None.\n        \"\"\"\n        x, y = drop_nans_and_infs(np.array(x), np.array(y))\n\n        # Convert error arrays to numpy arrays if provided\n        xerr_array = np.array(xerr) if xerr is not None else np.zeros(shape=x.shape)\n        yerr_array = np.array(yerr) if yerr is not None else np.zeros(shape=y.shape)\n\n        self._datasets.append(\n            ErrorBarPlot(\n                x=x,\n                y=y,\n                xerr=xerr_array,\n                yerr=yerr_array,\n                marker=marker,\n                marker_style=marker_style,\n                hires_mode=hires_mode,\n            )\n        )\n        self._labels.append(label)\n        self.refresh(layout=True)\n\n    def bar(\n        self,\n        x: ArrayLike | list[str],\n        y: ArrayLike,\n        width: float | ArrayLike | None = None,\n        bar_style: str | list[str] = \"white\",\n        hires_mode: HiResMode | None = None,\n        label: str | None = None,\n    ) -&gt; None:\n        \"\"\"Graph dataset using a bar plot.\n\n        Bars are drawn as filled rectangles from y=0 to the specified y values.\n        If you supply hires_mode, the bars will be plotted using one of the\n        available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n        characters.\n\n        Args:\n            x: An ArrayLike with the x-coordinate values for the center of each bar,\n                or a list of strings for categorical data.\n            y: An ArrayLike with the height values for each bar.\n            width: Width of the bars in data coordinates. Can be a single value\n                for all bars, an array of widths for each bar, or None to auto-calculate\n                based on spacing. Defaults to None.\n            bar_style: A string with the style for all bars or a list of styles\n                for each bar. Defaults to \"white\".\n            hires_mode: A HiResMode enum or None to plot with full-cell blocks.\n                Defaults to None.\n            label: A string with the label for the dataset. Defaults to None.\n        \"\"\"\n        if isinstance(x, list) and x and isinstance(x[0], str):\n            categories = list(x)\n            x_values = np.arange(1, len(categories) + 1)\n            self.set_x_formatter(CategoricalAxisFormatter(categories))\n            self.set_xticks(x_values.tolist())\n        else:\n            x_values = np.array(x)\n\n        x_values, y_values = drop_nans_and_infs(x_values, np.array(y))\n\n        # Calculate default width if not provided\n        if width is None:\n            if len(x_values) &gt; 1:\n                # Use 80% of the minimum spacing between bars\n                spacings = np.diff(np.sort(x_values))\n                width = 0.8 * float(np.min(spacings))\n            else:\n                # Single bar, use a reasonable default\n                width = 0.8\n\n        # Convert width to array if it's a scalar\n        width_array: FloatArray\n        if isinstance(width, (int, float, np.number)):\n            width_array = np.full_like(x_values, width, dtype=float)\n        else:\n            width_array = np.array(width, dtype=float)\n\n        self._datasets.append(\n            BarPlot(\n                x=x_values,\n                y=y_values,\n                width=width_array,\n                bar_style=bar_style,\n                hires_mode=hires_mode,\n            )\n        )\n        self._labels.append(label)\n        self.refresh(layout=True)\n\n    def add_v_line(\n        self, x: float, line_style: str = \"white\", label: str | None = None\n    ) -&gt; None:\n        \"\"\"Draw a vertical line on the plot.\n\n        Args:\n            x: The x-coordinate where the vertical line will be placed.\n            line_style: A string with the style of the line. Defaults to \"white\".\n            label: A string with the label for the line. Defaults to None.\n        \"\"\"\n        self._v_lines.append(VLinePlot(x=x, line_style=line_style))\n        self._v_lines_labels.append(label)\n        self.refresh(layout=True)\n\n    def set_xlimits(self, xmin: float | None = None, xmax: float | None = None) -&gt; None:\n        \"\"\"Set the limits of the x axis.\n\n        Args:\n            xmin: A float with the minimum x value or None for autoscaling.\n                Defaults to None.\n            xmax: A float with the maximum x value or None for autoscaling.\n                Defaults to None.\n        \"\"\"\n        self._user_x_min = xmin\n        self._user_x_max = xmax\n        self._auto_x_min = xmin is None\n        self._auto_x_max = xmax is None\n        self._x_min = xmin if xmin is not None else 0.0\n        self._x_max = xmax if xmax is not None else 1.0\n        self.refresh(layout=True)\n\n    def set_ylimits(self, ymin: float | None = None, ymax: float | None = None) -&gt; None:\n        \"\"\"Set the limits of the y axis.\n\n        Args:\n            ymin: A float with the minimum y value or None for autoscaling.\n                Defaults to None.\n            ymax: A float with the maximum y value or None for autoscaling.\n                Defaults to None.\n        \"\"\"\n        self._user_y_min = ymin\n        self._user_y_max = ymax\n        self._auto_y_min = ymin is None\n        self._auto_y_max = ymax is None\n        self._y_min = ymin if ymin is not None else 0.0\n        self._y_max = ymax if ymax is not None else 1.0\n        self.refresh(layout=True)\n\n    def set_xlabel(self, label: str) -&gt; None:\n        \"\"\"Set a label for the x axis.\n\n        Args:\n            label: A string with the label text.\n        \"\"\"\n        self._x_label = label\n\n    def set_ylabel(self, label: str) -&gt; None:\n        \"\"\"Set a label for the y axis.\n\n        Args:\n            label: A string with the label text.\n        \"\"\"\n        self._y_label = label\n\n    def set_xticks(self, ticks: Sequence[float] | None = None) -&gt; None:\n        \"\"\"Set the x axis ticks.\n\n        Use None for autoscaling, an empty list to hide the ticks.\n\n        Args:\n            ticks: An iterable with the tick values.\n        \"\"\"\n        self._x_ticks = ticks\n\n    def set_yticks(self, ticks: Sequence[float] | None = None) -&gt; None:\n        \"\"\"Set the y axis ticks.\n\n        Use None for autoscaling, an empty list to hide the ticks.\n\n        Args:\n            ticks: An iterable with the tick values.\n        \"\"\"\n        self._y_ticks = ticks\n\n    def set_x_formatter(self, formatter: AxisFormatter) -&gt; None:\n        \"\"\"Set the formatter for the x axis.\n\n        Args:\n            formatter: An AxisFormatter instance to use for formatting x-axis ticks.\n        \"\"\"\n        self._x_formatter = formatter\n\n    def set_y_formatter(self, formatter: AxisFormatter) -&gt; None:\n        \"\"\"Set the formatter for the y axis.\n\n        Args:\n            formatter: An AxisFormatter instance to use for formatting y-axis ticks.\n        \"\"\"\n        self._y_formatter = formatter\n\n    def show_legend(\n        self,\n        location: LegendLocation = LegendLocation.TOPRIGHT,\n        is_visible: bool = True,\n    ) -&gt; None:\n        \"\"\"Show or hide the legend for the datasets in the plot.\n\n        Args:\n            is_visible: A boolean indicating whether to show the legend.\n                Defaults to True.\n        \"\"\"\n        self.query_one(\"#legend\", Static).display = is_visible\n        if not is_visible:\n            return\n\n        self._position_legend()\n\n        legend_lines = []\n        if isinstance(location, LegendLocation):\n            self._legend_location = location\n        else:\n            raise TypeError(\n                f\"Expected LegendLocation, got {type(location).__name__} instead.\"\n            )\n\n        for label, dataset in zip(self._labels, self._datasets):\n            if label is not None:\n                if isinstance(dataset, LinePlot):\n                    marker = LEGEND_LINE[dataset.hires_mode]\n                    style = dataset.line_style\n                elif isinstance(dataset, ErrorBarPlot):\n                    marker = (\n                        dataset.marker or \"\u253c\"\n                        if dataset.hires_mode is None\n                        else LEGEND_MARKER[dataset.hires_mode]\n                    ).center(3)\n                    style = dataset.marker_style\n                elif isinstance(dataset, BarPlot):\n                    marker = \"\u2588\u2588\u2588\"\n                    # Use first style if bar_style is a list\n                    style = (\n                        dataset.bar_style[0]\n                        if isinstance(dataset.bar_style, list)\n                        else dataset.bar_style\n                    )\n                elif isinstance(dataset, ScatterPlot):\n                    marker = (\n                        dataset.marker\n                        if dataset.hires_mode is None\n                        else LEGEND_MARKER[dataset.hires_mode]\n                    ).center(3)\n                    style = dataset.marker_style\n                else:\n                    # unsupported dataset type\n                    continue\n                text = Text(marker)\n                text.stylize(style)\n                text.append(f\" {label}\")\n                legend_lines.append(text.markup)\n\n        for label, vline in zip(self._v_lines_labels, self._v_lines):\n            if label is not None:\n                marker = \"\u2502\".center(3)\n                style = vline.line_style\n                text = Text(marker)\n                text.stylize(style)\n                text.append(f\" {label}\")\n                legend_lines.append(text.markup)\n\n        self.query_one(\"#legend\", Static).update(\n            Text.from_markup(\"\\n\".join(legend_lines))\n        )\n\n    def _position_legend(self) -&gt; None:\n        \"\"\"Position the legend in the plot widget using absolute offsets.\n\n        The position of the legend is calculated by checking the legend origin\n        location (top left, bottom right, etc.) and an offset resulting from the\n        user dragging the legend to another location. Then the nearest corner of\n        the plot widget is determined and the legend is anchored to that corner\n        and a new relative offset is determined. The end result is that the user\n        can place the legend anywhere in the plot, but when the user resizes the\n        plot the legend will stay fixed relative to the nearest corner.\n        \"\"\"\n\n        position = (\n            self._get_legend_origin_coordinates(self._legend_location)\n            + self._legend_relative_offset\n        )\n        distances: dict[LegendLocation, float] = {\n            location: self._get_legend_origin_coordinates(location).get_distance_to(\n                position\n            )\n            for location in LegendLocation\n        }\n        nearest_location = min(distances, key=lambda loc: distances[loc])\n        self._legend_location = nearest_location\n        self._legend_relative_offset = position - self._get_legend_origin_coordinates(\n            nearest_location\n        )\n\n        legend = self.query_one(\"#legend\", Static)\n        legend.offset = position\n\n    def _get_legend_origin_coordinates(self, location: LegendLocation) -&gt; Offset:\n        \"\"\"Calculate the (x, y) origin coordinates for positioning the legend.\n\n        The coordinates are determined based on the legend's location (top-left,\n        top-right, bottom-left, bottom-right), the size of the data rectangle,\n        the length of the legend labels, and the margins and border spacing.\n        User adjustments (dragging the legend to a different position) are _not_\n        taken into account, but are applied later.\n\n        Returns:\n            A (x, y) tuple of ints representing the coordinates of the top-left\n            corner of the legend within the plot widget.\n        \"\"\"\n        canvas = self.query_one(\"#plot\", Canvas)\n        legend = self.query_one(\"#legend\", Static)\n\n        # Collect all labels that will appear in the legend\n        all_labels = [label for label in self._labels if label is not None]\n        all_labels.extend(\n            [label for label in self._v_lines_labels if label is not None]\n        )\n\n        # markers and lines in the legend are 3 characters wide, plus a space, so 4\n        max_length = 4 + max((len(s) for s in all_labels), default=0)\n\n        if location in (LegendLocation.TOPLEFT, LegendLocation.BOTTOMLEFT):\n            x0 = self.margin_left + 1\n        else:\n            # LegendLocation is TOPRIGHT or BOTTOMRIGHT\n            x0 = self.margin_left + canvas.size.width - 1 - max_length\n            # leave room for the border\n            x0 -= legend.styles.border.spacing.left + legend.styles.border.spacing.right\n\n        if location in (LegendLocation.TOPLEFT, LegendLocation.TOPRIGHT):\n            y0 = self.margin_top + 1\n        else:\n            # LegendLocation is BOTTOMLEFT or BOTTOMRIGHT\n            y0 = self.margin_top + canvas.size.height - 1 - len(all_labels)\n            # leave room for the border\n            y0 -= legend.styles.border.spacing.top + legend.styles.border.spacing.bottom\n        return Offset(x0, y0)\n\n    def refresh(\n        self,\n        *regions: Region,\n        repaint: bool = True,\n        layout: bool = False,\n        recompose: bool = False,\n    ) -&gt; Self:\n        \"\"\"Refresh the widget.\n\n        Args:\n            regions: Specific regions to refresh.\n            repaint: Whether to repaint the widget. Defaults to True.\n            layout: Whether to refresh the layout. Defaults to False.\n            recompose: Whether to recompose the widget. Defaults to False.\n\n        Returns:\n            The widget instance for method chaining.\n        \"\"\"\n        if layout is True:\n            self._needs_rerender = True\n        return super().refresh(\n            *regions, repaint=repaint, layout=layout, recompose=recompose\n        )\n\n    def render(self) -&gt; RenderResult:\n        \"\"\"Render the plot widget.\n\n        Returns:\n            An empty string as rendering is done on canvases.\n        \"\"\"\n        if self._needs_rerender:\n            self._needs_rerender = False\n            self._render_plot()\n        return \"\"\n\n    def _render_plot(self) -&gt; None:\n        \"\"\"Render all plot elements including datasets, axes, ticks, and labels.\"\"\"\n        try:\n            if (canvas := self.query_one(\"#plot\", Canvas))._canvas_size is None:\n                return\n        except NoMatches:\n            # Refresh is called before the widget is composed\n            return\n\n        # clear canvas\n        canvas.reset()\n\n        # determine axis limits\n        if self._datasets or self._v_lines:\n            xs = []\n            ys = []\n\n            # Collect x and y values, accounting for bar widths\n            for dataset in self._datasets:\n                if isinstance(dataset, BarPlot):\n                    # For bar plots, include the left and right edges\n                    x_left = dataset.x - dataset.width / 2\n                    x_right = dataset.x + dataset.width / 2\n                    xs.append(x_left)\n                    xs.append(x_right)\n                    # Include both y=0 and the bar heights\n                    ys.append(np.zeros_like(dataset.y))\n                    ys.append(dataset.y)\n                else:\n                    xs.append(dataset.x)\n                    ys.append(dataset.y)\n\n            if self._v_lines:\n                xs.append(np.array([vline.x for vline in self._v_lines]))\n\n            if self._auto_x_min:\n                non_empty_xs = [x for x in xs if len(x) &gt; 0]\n                if non_empty_xs:\n                    self._x_min = float(np.min([np.min(x) for x in non_empty_xs]))\n            if self._auto_x_max:\n                non_empty_xs = [x for x in xs if len(x) &gt; 0]\n                if non_empty_xs:\n                    self._x_max = float(np.max([np.max(x) for x in non_empty_xs]))\n            if self._auto_y_min:\n                non_empty_ys = [y for y in ys if len(y) &gt; 0]\n                if non_empty_ys:\n                    self._y_min = float(np.min([np.min(y) for y in non_empty_ys]))\n            if self._auto_y_max:\n                non_empty_ys = [y for y in ys if len(y) &gt; 0]\n                if non_empty_ys:\n                    self._y_max = float(np.max([np.max(y) for y in non_empty_ys]))\n\n            if self._x_min == self._x_max:\n                self._x_min -= 1e-6\n                self._x_max += 1e-6\n            if self._y_min == self._y_max:\n                self._y_min -= 1e-6\n                self._y_max += 1e-6\n\n        # render datasets\n        for dataset in self._datasets:\n            if isinstance(dataset, LinePlot):\n                self._render_line_plot(dataset)\n            elif isinstance(dataset, ErrorBarPlot):\n                self._render_errorbar_plot(dataset)\n            elif isinstance(dataset, BarPlot):\n                self._render_bar_plot(dataset)\n            elif isinstance(dataset, ScatterPlot):\n                self._render_scatter_plot(dataset)\n\n        # render axis, ticks and labels\n        canvas.draw_rectangle_box(\n            0,\n            0,\n            canvas.size.width - 1,\n            canvas.size.height - 1,\n            thickness=2,\n            style=str(self.get_component_rich_style(\"plot--axis\")),\n        )\n        # render vlines\n        for vline in self._v_lines:\n            self._render_v_line_plot(vline)\n        # render tick marks and labels\n        self._render_x_ticks()\n        self._render_y_ticks()\n        # render axis labels\n        self._render_x_label()\n        self._render_y_label()\n\n    def _render_scatter_plot(self, dataset: ScatterPlot) -&gt; None:\n        \"\"\"Render a scatter plot dataset on the canvas.\n\n        Args:\n            dataset: The scatter plot dataset to render.\n        \"\"\"\n        canvas = self.query_one(\"#plot\", Canvas)\n        if dataset.hires_mode:\n            hires_pixels = [\n                self.get_hires_pixel_from_coordinate(xi, yi)\n                for xi, yi in zip(dataset.x, dataset.y)\n            ]\n            canvas.set_hires_pixels(\n                hires_pixels, style=dataset.marker_style, hires_mode=dataset.hires_mode\n            )\n        else:\n            pixels = [\n                self.get_pixel_from_coordinate(xi, yi)\n                for xi, yi in zip(dataset.x, dataset.y)\n            ]\n            for pixel in pixels:\n                canvas.set_pixel(\n                    *pixel, char=dataset.marker, style=dataset.marker_style\n                )\n\n    def _render_errorbar_plot(self, dataset: ErrorBarPlot) -&gt; None:\n        \"\"\"Render the error bars for an error bar plot.\n\n        Both full-width and half-width characters are used for the errorbar. If\n        the error bars become very small, a dot is rendered at the location of\n        the data point. The markers are rendered last so that error bars never\n        obscure the data points. If hires plotting is used, the markers are\n        correctly rendered using hires modes.\n\n        Args:\n            dataset: The error bar plot dataset to render.\n        \"\"\"\n\n        def partial_lengths(length: FloatScalar) -&gt; tuple[float, int, float]:\n            \"\"\"Return partial lengths of error bar.\n\n            An error bar with length 3 should be rendered as: +, --, (extra half\n            cell).\n\n            Returns:\n                A tuple containing the length of the central half cell, the\n                extra full-width cells and an extra half cell if needed.\n            \"\"\"\n            rounded_length = round(length * 2) / 2\n            if rounded_length &lt; 0.5:\n                return 0.0, 0, 0.0\n            else:\n                extra_length = rounded_length - 0.5\n                return 0.5, int(extra_length // 1), extra_length % 1\n\n        canvas = self.query_one(\"#plot\", Canvas)\n\n        # store marker information for later rendering\n        markers = []\n        # render error bars\n        for xi, yi, xerr, yerr in zip(dataset.x, dataset.y, dataset.xerr, dataset.yerr):\n            center_px, center_py = self.get_pixel_from_coordinate(xi, yi)\n            x0, y0 = self.get_hires_pixel_from_coordinate(0, 0)\n\n            if np.isfinite(xerr):\n                xe, _ = self.get_hires_pixel_from_coordinate(xerr, 0)\n                x_length = xe - x0\n                center_width, int_width, frac_width = partial_lengths(x_length)\n\n                # draw the full-width characters\n                canvas.draw_line(\n                    center_px - int_width,\n                    center_py,\n                    center_px + int_width,\n                    center_py,\n                    char=\"\u2500\",\n                    style=dataset.marker_style,\n                )\n\n                # render half-width characters if needed at the edges\n                if frac_width &gt; 0.0:\n                    canvas.set_pixel(\n                        center_px - int_width - 1,\n                        center_py,\n                        char=\"\u2576\",\n                        style=dataset.marker_style,\n                    )\n                    canvas.set_pixel(\n                        center_px + int_width + 1,\n                        center_py,\n                        char=\"\u2574\",\n                        style=dataset.marker_style,\n                    )\n            else:\n                center_width = 0.0\n\n            if np.isfinite(yerr):\n                # determine length of error bars\n                _, ye = self.get_hires_pixel_from_coordinate(0.0, yerr)\n                y_length = y0 - ye\n                center_height, int_height, frac_height = partial_lengths(y_length)\n\n                # draw the full-width characters\n                canvas.draw_line(\n                    center_px,\n                    center_py - int_height,\n                    center_px,\n                    center_py + int_height,\n                    char=\"\u2502\",\n                    style=dataset.marker_style,\n                )\n\n                # render half-width characters if needed at the edges\n                if frac_height &gt; 0.0:\n                    canvas.set_pixel(\n                        center_px,\n                        center_py - int_height - 1,\n                        char=\"\u2577\",\n                        style=dataset.marker_style,\n                    )\n                    canvas.set_pixel(\n                        center_px,\n                        center_py + int_height + 1,\n                        char=\"\u2575\",\n                        style=dataset.marker_style,\n                    )\n            else:\n                center_height = 0.0\n\n            # store marker information for later rendering\n            if dataset.marker:\n                marker = dataset.marker\n            else:\n                if center_width &gt; 0.0 and center_height &gt; 0.0:\n                    marker = \"\u253c\"\n                else:\n                    marker = \"\u00b7\"\n            markers.append((center_px, center_py, marker, dataset.marker_style))\n\n        # render hires markers, if specified\n        if dataset.hires_mode:\n            self._render_scatter_plot(dataset)\n        else:\n            for marker in markers:\n                canvas.set_pixel(*marker)\n\n    def _render_line_plot(self, dataset: LinePlot) -&gt; None:\n        \"\"\"Render a line plot dataset on the canvas.\n\n        Args:\n            dataset: The line plot dataset to render.\n        \"\"\"\n        canvas = self.query_one(\"#plot\", Canvas)\n\n        if dataset.hires_mode:\n            hires_pixels = [\n                self.get_hires_pixel_from_coordinate(xi, yi)\n                for xi, yi in zip(dataset.x, dataset.y)\n            ]\n            coordinates = [\n                (*hires_pixels[i - 1], *hires_pixels[i])\n                for i in range(1, len(hires_pixels))\n            ]\n            canvas.draw_hires_lines(\n                coordinates, style=dataset.line_style, hires_mode=dataset.hires_mode\n            )\n        else:\n            pixels = [\n                self.get_pixel_from_coordinate(xi, yi)\n                for xi, yi in zip(dataset.x, dataset.y)\n            ]\n            for i in range(1, len(pixels)):\n                canvas.draw_line(*pixels[i - 1], *pixels[i], style=dataset.line_style)\n\n    def _render_bar_plot(self, dataset: BarPlot) -&gt; None:\n        \"\"\"Render a bar plot dataset on the canvas.\n\n        Bars are drawn as filled quads from y=0 to the specified y values.\n        The method uses either draw_filled_quad or draw_filled_hires_quad\n        depending on whether a hires mode was selected.\n\n        Args:\n            dataset: The bar plot dataset to render.\n        \"\"\"\n        canvas = self.query_one(\"#plot\", Canvas)\n\n        # Determine if bar_style is a single style or a list\n        is_style_array = isinstance(dataset.bar_style, list)\n\n        for i, (xi, yi, width) in enumerate(zip(dataset.x, dataset.y, dataset.width)):\n            # Get the style for this bar\n            style = dataset.bar_style[i] if is_style_array else dataset.bar_style\n            assert isinstance(style, str)\n\n            # Calculate the four corners of the bar in data coordinates\n            x_left = xi - width / 2\n            x_right = xi + width / 2\n            y_bottom = 0.0\n            y_top = yi\n\n            if dataset.hires_mode:\n                # Use high-resolution quad rendering (clockwise from bottom-left)\n                x0, y0 = self.get_hires_pixel_from_coordinate(x_left, y_top)\n                x1, y1 = self.get_hires_pixel_from_coordinate(x_right, y_bottom)\n                canvas.draw_filled_hires_rectangle(\n                    x0, y0, x1, y1, hires_mode=dataset.hires_mode, style=style\n                )\n            else:\n                # Use standard quad rendering (clockwise from bottom-left)\n                x0, y0 = self.get_pixel_from_coordinate(x_left, y_top)\n                x1, y1 = self.get_pixel_from_coordinate(x_right, y_bottom)\n                canvas.draw_filled_rectangle(x0, y0, x1, y1, style=style)\n\n    def _render_v_line_plot(self, vline: VLinePlot) -&gt; None:\n        \"\"\"Render a vertical line on the canvas.\n\n        The vertical line is drawn from the top to the bottom of the scale\n        rectangle and is connected to the scale rectangle.\n\n        Args:\n            vline: A VLinePlot dataclass instance containing the x-coordinate\n                and line style.\n        \"\"\"\n        canvas = self.query_one(\"#plot\", Canvas)\n        x, _ = self.get_pixel_from_coordinate(vline.x, 0)\n        canvas.draw_line(\n            x, 1, x, self._scale_rectangle.bottom - 1, style=vline.line_style, char=\"\u2502\"\n        )\n        style = str(self.get_component_rich_style(\"plot--axis\"))\n        canvas.set_pixel(x, 0, BOX_CHARACTERS[(0, 2, 2, 2)], style=style)\n        canvas.set_pixel(\n            x, self._scale_rectangle.bottom, BOX_CHARACTERS[(2, 2, 0, 2)], style=style\n        )\n\n    def _render_x_ticks(self) -&gt; None:\n        \"\"\"Render tick marks and labels for the x-axis.\"\"\"\n        canvas = self.query_one(\"#plot\", Canvas)\n        bottom_margin = self.query_one(\"#margin-bottom\", Canvas)\n        bottom_margin.reset()\n\n        x_ticks: Sequence[float]\n        if self._x_ticks is None:\n            x_ticks, x_labels = self._x_formatter.get_ticks_and_labels(\n                self._x_min, self._x_max\n            )\n        else:\n            x_ticks = self._x_ticks\n            x_labels = self._x_formatter.get_labels_for_ticks(x_ticks)\n        for tick, label in zip(x_ticks, x_labels):\n            if tick &lt; self._x_min or tick &gt; self._x_max:\n                continue\n            align = TextAlign.CENTER\n            # only interested in the x-coordinate, set y to 0.0\n            x, _ = self.get_pixel_from_coordinate(tick, 0.0)\n\n            if not isinstance(self._x_formatter, CategoricalAxisFormatter):\n                if tick == self._x_min:\n                    x -= 1\n                elif tick == self._x_max:\n                    align = TextAlign.RIGHT\n            for y, quad in [\n                # put ticks at top and bottom of scale rectangle\n                (0, (2, 0, 0, 0)),\n                (self._scale_rectangle.bottom, (0, 0, 2, 0)),\n            ]:\n                new_pixel = self.combine_quad_with_pixel(quad, canvas, x, y)\n                canvas.set_pixel(\n                    x,\n                    y,\n                    new_pixel,\n                    style=str(self.get_component_rich_style(\"plot--axis\")),\n                )\n            bottom_margin.write_text(\n                x + self.margin_left,\n                0,\n                f\"[{self.get_component_rich_style('plot--tick')}]{label}\",\n                align,\n            )\n\n    def _render_y_ticks(self) -&gt; None:\n        \"\"\"Render tick marks and labels for the y-axis.\"\"\"\n        canvas = self.query_one(\"#plot\", Canvas)\n        left_margin = self.query_one(\"#margin-left\", Canvas)\n        left_margin.reset()\n\n        y_ticks: Sequence[float]\n        if self._y_ticks is None:\n            y_ticks, y_labels = self._y_formatter.get_ticks_and_labels(\n                self._y_min, self._y_max\n            )\n        else:\n            y_ticks = self._y_ticks\n            y_labels = self._y_formatter.get_labels_for_ticks(y_ticks)\n        # truncate y-labels to the left margin width\n        y_labels = [label[: self.margin_left - 1] for label in y_labels]\n        align = TextAlign.RIGHT\n        for tick, label in zip(y_ticks, y_labels):\n            if tick &lt; self._y_min or tick &gt; self._y_max:\n                continue\n            # only interested in the y-coordinate, set x to 0.0\n            _, y = self.get_pixel_from_coordinate(0.0, tick)\n            if tick == self._y_min:\n                y += 1\n            for x, quad in [\n                # put ticks at left and right of scale rectangle\n                (0, (0, 0, 0, 2)),\n                (self._scale_rectangle.right, (0, 2, 0, 0)),\n            ]:\n                new_pixel = self.combine_quad_with_pixel(quad, canvas, x, y)\n                canvas.set_pixel(\n                    x,\n                    y,\n                    new_pixel,\n                    style=str(self.get_component_rich_style(\"plot--axis\")),\n                )\n            left_margin.write_text(\n                self.margin_left - 2,\n                y,\n                f\"[{self.get_component_rich_style('plot--tick')}]{label}\",\n                align,\n            )\n\n    def _render_x_label(self) -&gt; None:\n        \"\"\"Render the x-axis label.\"\"\"\n        canvas = self.query_one(\"#plot\", Canvas)\n        margin = self.query_one(\"#margin-bottom\", Canvas)\n        margin.write_text(\n            canvas.size.width // 2 + self.margin_left,\n            2,\n            f\"[{self.get_component_rich_style('plot--label')}]{self._x_label}\",\n            TextAlign.CENTER,\n        )\n\n    def _render_y_label(self) -&gt; None:\n        \"\"\"Render the y-axis label.\"\"\"\n        margin = self.query_one(\"#margin-top\", Canvas)\n        margin.write_text(\n            self.margin_left - 2,\n            0,\n            f\"[{self.get_component_rich_style('plot--label')}]{self._y_label}\",\n            TextAlign.CENTER,\n        )\n\n    def combine_quad_with_pixel(\n        self, quad: tuple[int, int, int, int], canvas: Canvas, x: int, y: int\n    ) -&gt; str:\n        \"\"\"Combine a box-drawing quad with an existing pixel to create seamless connections.\n\n        Args:\n            quad: A tuple of 4 integers representing box drawing directions (top, right, bottom, left).\n            canvas: The canvas containing the pixel.\n            x: X-coordinate of the pixel.\n            y: Y-coordinate of the pixel.\n\n        Returns:\n            A box-drawing character that combines both quads.\n        \"\"\"\n        pixel = canvas.get_pixel(x, y)[0]\n        for current_quad, v in BOX_CHARACTERS.items():\n            if v == pixel:\n                break\n        else:\n            raise ValueError(f\"Pixel '{pixel}' is not a valid box drawing character.\")\n        new_quad = combine_quads(current_quad, quad)\n        return BOX_CHARACTERS[new_quad]\n\n    def get_pixel_from_coordinate(\n        self, x: FloatScalar, y: FloatScalar\n    ) -&gt; tuple[int, int]:\n        \"\"\"Convert data coordinates to canvas pixel coordinates.\n\n        Args:\n            x: X-coordinate in data space.\n            y: Y-coordinate in data space.\n\n        Returns:\n            A tuple of (x, y) pixel coordinates on the canvas.\n        \"\"\"\n        return map_coordinate_to_pixel(\n            x,\n            y,\n            self._x_min,\n            self._x_max,\n            self._y_min,\n            self._y_max,\n            region=self._scale_rectangle,\n        )\n\n    def get_hires_pixel_from_coordinate(\n        self, x: FloatScalar, y: FloatScalar\n    ) -&gt; tuple[FloatScalar, FloatScalar]:\n        \"\"\"Convert data coordinates to high-resolution pixel coordinates.\n\n        Args:\n            x: X-coordinate in data space.\n            y: Y-coordinate in data space.\n\n        Returns:\n            A tuple of (x, y) high-resolution pixel coordinates with sub-character precision.\n        \"\"\"\n        return map_coordinate_to_hires_pixel(\n            x,\n            y,\n            self._x_min,\n            self._x_max,\n            self._y_min,\n            self._y_max,\n            region=self._scale_rectangle,\n        )\n\n    def get_coordinate_from_pixel(self, x: int, y: int) -&gt; tuple[float, float]:\n        \"\"\"Convert canvas pixel coordinates to data coordinates.\n\n        Args:\n            x: X-coordinate in pixel space.\n            y: Y-coordinate in pixel space.\n\n        Returns:\n            A tuple of (x, y) coordinates in data space.\n        \"\"\"\n        return map_pixel_to_coordinate(\n            x,\n            y,\n            self._x_min,\n            self._x_max,\n            self._y_min,\n            self._y_max,\n            region=self._scale_rectangle,\n        )\n\n    def _zoom_with_mouse(\n        self, event: MouseScrollDown | MouseScrollUp, factor: float\n    ) -&gt; None:\n        \"\"\"Handle zoom operations centered on the mouse cursor position.\n\n        Args:\n            event: The mouse scroll event triggering the zoom.\n            factor: The zoom factor to apply (positive for zoom in, negative for\n                zoom out).\n        \"\"\"\n        if not self._allow_pan_and_zoom:\n            return\n\n        if self.invert_mouse_wheel:\n            factor *= -1\n\n        if (offset := event.get_content_offset(self)) is not None:\n            widget, _ = self.screen.get_widget_at(event.screen_x, event.screen_y)\n            canvas = self.query_one(\"#plot\", Canvas)\n            if widget.id == \"margin-bottom\":\n                offset = event.screen_offset - self.screen.get_offset(canvas)\n            x, y = self.get_coordinate_from_pixel(offset.x, offset.y)\n            zoom_x = True if widget.id in (\"plot\", \"margin-bottom\") else False\n            zoom_y = True if widget.id in (\"plot\", \"margin-left\") else False\n            self._zoom(x, y, factor, zoom_x, zoom_y)\n\n    def _zoom_with_keyboard(\n        self, factor: float, zoom_x: bool = True, zoom_y: bool = True\n    ) -&gt; None:\n        \"\"\"Handle zoom operations centered on the plot's center point.\n\n        Args:\n            factor: The zoom factor to apply (positive for zoom in, negative for\n                zoom out).\n            zoom_x: Whether to zoom in the x direction. Defaults to True.\n            zoom_y: Whether to zoom in the y direction. Defaults to True.\n        \"\"\"\n        cx = mean([self._x_min, self._x_max])\n        cy = mean([self._y_min, self._y_max])\n        self._zoom(cx, cy, factor, zoom_x=zoom_x, zoom_y=zoom_y)\n\n    def _zoom(\n        self,\n        center_x: float,\n        center_y: float,\n        factor: float,\n        zoom_x: bool,\n        zoom_y: bool,\n    ) -&gt; None:\n        \"\"\"Perform zoom operation around a center point.\n\n        The zoom is performed using the formula: new_limit = (old_limit + factor\n        * center) / (1 + factor) This keeps the center point fixed while scaling\n        the distance from the center to each limit.\n\n        Args:\n            center_x: The x-coordinate to zoom around (in data coordinates).\n            center_y: The y-coordinate to zoom around (in data coordinates).\n            factor: The zoom factor (positive to zoom in, negative to zoom out).\n            zoom_x: Whether to zoom in the x direction.\n            zoom_y: Whether to zoom in the y direction.\n        \"\"\"\n        if zoom_x:\n            self._auto_x_min = False\n            self._auto_x_max = False\n            self._x_min = (self._x_min + factor * center_x) / (1 + factor)\n            self._x_max = (self._x_max + factor * center_x) / (1 + factor)\n        if zoom_y:\n            self._auto_y_min = False\n            self._auto_y_max = False\n            self._y_min = (self._y_min + factor * center_y) / (1 + factor)\n            self._y_max = (self._y_max + factor * center_y) / (1 + factor)\n        self.post_message(\n            self.ScaleChanged(self, self._x_min, self._x_max, self._y_min, self._y_max)\n        )\n        self.refresh(layout=True)\n\n    @on(MouseScrollDown)\n    def zoom_in(self, event: MouseScrollDown) -&gt; None:\n        \"\"\"Zoom into the plot when scrolling down.\n\n        Args:\n            event: The mouse scroll down event.\n        \"\"\"\n        event.stop()\n        self._zoom_with_mouse(event, self.MOUSE_ZOOM_FACTOR)\n\n    @on(MouseScrollUp)\n    def zoom_out(self, event: MouseScrollUp) -&gt; None:\n        \"\"\"Zoom out of the plot when scrolling up.\n\n        Args:\n            event: The mouse scroll up event.\n        \"\"\"\n        event.stop()\n        self._zoom_with_mouse(event, -self.MOUSE_ZOOM_FACTOR)\n\n    def action_zoom_in(self) -&gt; None:\n        self._zoom_with_keyboard(self.KEYBOARD_ZOOM_FACTOR)\n\n    def action_zoom_out(self) -&gt; None:\n        self._zoom_with_keyboard(-self.KEYBOARD_ZOOM_FACTOR)\n\n    def action_zoom_x_in(self) -&gt; None:\n        \"\"\"Zoom in on the x-axis only.\"\"\"\n        self._zoom_with_keyboard(self.KEYBOARD_ZOOM_FACTOR, zoom_x=True, zoom_y=False)\n\n    def action_zoom_x_out(self) -&gt; None:\n        \"\"\"Zoom out on the x-axis only.\"\"\"\n        self._zoom_with_keyboard(-self.KEYBOARD_ZOOM_FACTOR, zoom_x=True, zoom_y=False)\n\n    def action_zoom_y_in(self) -&gt; None:\n        \"\"\"Zoom in on the y-axis only.\"\"\"\n        self._zoom_with_keyboard(self.KEYBOARD_ZOOM_FACTOR, zoom_x=False, zoom_y=True)\n\n    def action_zoom_y_out(self) -&gt; None:\n        \"\"\"Zoom out on the y-axis only.\"\"\"\n        self._zoom_with_keyboard(-self.KEYBOARD_ZOOM_FACTOR, zoom_x=False, zoom_y=True)\n\n    def action_pan_left(self) -&gt; None:\n        \"\"\"Pan the plot to the left.\"\"\"\n        self._pan(self.KEYBOARD_PAN_FACTOR, 0)\n\n    def action_pan_right(self) -&gt; None:\n        \"\"\"Pan the plot to the right.\"\"\"\n        self._pan(-self.KEYBOARD_PAN_FACTOR, 0)\n\n    def action_pan_up(self) -&gt; None:\n        \"\"\"Pan the plot upward.\"\"\"\n        self._pan(0, self.KEYBOARD_PAN_FACTOR)\n\n    def action_pan_down(self) -&gt; None:\n        \"\"\"Pan the plot downward.\"\"\"\n        self._pan(0, -self.KEYBOARD_PAN_FACTOR)\n\n    @on(MouseDown)\n    def start_dragging_legend(self, event: MouseDown) -&gt; None:\n        \"\"\"Start dragging the legend when clicked with left mouse button.\n\n        Args:\n            event: The mouse down event.\n        \"\"\"\n        widget, _ = self.screen.get_widget_at(event.screen_x, event.screen_y)\n        if event.button == 1 and widget.id == \"legend\":\n            self._is_dragging_legend = True\n            widget.add_class(\"dragged\")\n            event.stop()\n\n    @on(MouseUp)\n    def stop_dragging_legend(self, event: MouseUp) -&gt; None:\n        \"\"\"Stop dragging the legend when left mouse button is released.\n\n        Args:\n            event: The mouse up event.\n        \"\"\"\n        if event.button == 1 and self._is_dragging_legend:\n            self._is_dragging_legend = False\n            self.query_one(\"#legend\").remove_class(\"dragged\")\n            event.stop()\n\n    @on(MouseMove)\n    def drag_with_mouse(self, event: MouseMove) -&gt; None:\n        \"\"\"Handle mouse drag operations for panning the plot or the legend.\n\n        Args:\n            event: The mouse move event.\n        \"\"\"\n        if not self._allow_pan_and_zoom:\n            return\n        if event.button == 0:\n            # If no button is pressed, don't drag.\n            return\n\n        if self._is_dragging_legend:\n            self._drag_legend(event)\n        else:\n            self._pan_plot_with_mouse(event)\n\n    def _drag_legend(self, event: MouseMove) -&gt; None:\n        \"\"\"Update legend position while dragging.\n\n        Args:\n            event: The mouse move event with drag delta information.\n        \"\"\"\n        self._legend_relative_offset += event.delta\n        self._position_legend()\n        self.query_one(\"#legend\").refresh(layout=True)\n\n    def _pan_plot_with_mouse(self, event: MouseMove) -&gt; None:\n        \"\"\"Handle pan operations using mouse movement.\n\n        Args:\n            event: The mouse move event with drag delta information.\n        \"\"\"\n        assert event.widget is not None\n        factor_x = event.delta_x if event.widget.id in (\"plot\", \"margin-bottom\") else 0\n        factor_y = event.delta_y if event.widget.id in (\"plot\", \"margin-left\") else 0\n        self._pan(factor_x, factor_y)\n\n    def _pan(self, factor_x: float, factor_y: float) -&gt; None:\n        \"\"\"Pan the plot by adjusting axis limits.\n\n        Args:\n            factor_x: The pan factor in the x direction (in pixel units).\n            factor_y: The pan factor in the y direction (in pixel units).\n        \"\"\"\n        # Calculate the data coordinate distance per pixel\n        x1, y1 = self.get_coordinate_from_pixel(1, 1)\n        x2, y2 = self.get_coordinate_from_pixel(2, 2)\n        dx, dy = x2 - x1, y1 - y2\n\n        # Convert pixel factors to data coordinate deltas\n        delta_x = dx * factor_x\n        delta_y = dy * factor_y\n        if delta_x != 0.0:\n            self._auto_x_min = False\n            self._auto_x_max = False\n            self._x_min -= delta_x\n            self._x_max -= delta_x\n        if delta_y != 0.0:\n            self._auto_y_min = False\n            self._auto_y_max = False\n            self._y_min += delta_y\n            self._y_max += delta_y\n        self.post_message(\n            self.ScaleChanged(self, self._x_min, self._x_max, self._y_min, self._y_max)\n        )\n        self.refresh(layout=True)\n\n    def action_reset_scales(self) -&gt; None:\n        \"\"\"Reset the plot scales to the user-defined or auto-scaled limits.\"\"\"\n        self.set_xlimits(self._user_x_min, self._user_x_max)\n        self.set_ylimits(self._user_y_min, self._user_y_max)\n        self.post_message(\n            self.ScaleChanged(self, self._x_min, self._x_max, self._y_min, self._y_max)\n        )\n        self.refresh()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.ScaleChanged","title":"<code>ScaleChanged</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message posted when the plot scale (axis limits) changes.</p> <p>Attributes:</p> Name Type Description <code>plot</code> <code>'PlotWidget'</code> <p>The PlotWidget instance that posted the message.</p> <code>x_min</code> <code>float</code> <p>Minimum value of the x-axis after the change.</p> <code>x_max</code> <code>float</code> <p>Maximum value of the x-axis after the change.</p> <code>y_min</code> <code>float</code> <p>Minimum value of the y-axis after the change.</p> <code>y_max</code> <code>float</code> <p>Maximum value of the y-axis after the change.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>@dataclass\nclass ScaleChanged(Message):\n    \"\"\"Message posted when the plot scale (axis limits) changes.\n\n    Attributes:\n        plot: The PlotWidget instance that posted the message.\n        x_min: Minimum value of the x-axis after the change.\n        x_max: Maximum value of the x-axis after the change.\n        y_min: Minimum value of the y-axis after the change.\n        y_max: Maximum value of the y-axis after the change.\n    \"\"\"\n\n    plot: \"PlotWidget\"\n    x_min: float\n    x_max: float\n    y_min: float\n    y_max: float\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.__init__","title":"<code>__init__(name=None, id=None, classes=None, *, allow_pan_and_zoom=True, invert_mouse_wheel=False, disabled=False)</code>","text":"<p>Initializes the plot widget with basic widget parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the widget.</p> <code>None</code> <code>id</code> <code>str | None</code> <p>The ID of the widget in the DOM.</p> <code>None</code> <code>classes</code> <code>str | None</code> <p>The CSS classes for the widget.</p> <code>None</code> <code>allow_pan_and_zoom</code> <code>bool</code> <p>Whether to allow panning and zooming the plot. Defaults to True.</p> <code>True</code> <code>invert_mouse_wheel</code> <code>bool</code> <p>When set to True the zooming direction is inverted when scrolling in and out of the widget. Defaults to False.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Whether the widget is disabled or not.</p> <code>False</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    id: str | None = None,\n    classes: str | None = None,\n    *,\n    allow_pan_and_zoom: bool = True,\n    invert_mouse_wheel: bool = False,\n    disabled: bool = False,\n) -&gt; None:\n    \"\"\"Initializes the plot widget with basic widget parameters.\n\n    Params:\n        name: The name of the widget.\n        id: The ID of the widget in the DOM.\n        classes: The CSS classes for the widget.\n        allow_pan_and_zoom: Whether to allow panning and zooming the plot.\n            Defaults to True.\n        invert_mouse_wheel: When set to True the zooming direction is inverted\n            when scrolling in and out of the widget. Defaults to False.\n        disabled: Whether the widget is disabled or not.\n    \"\"\"\n    super().__init__(\n        name=name,\n        id=id,\n        classes=classes,\n        disabled=disabled,\n    )\n    self._datasets = []\n    self._labels = []\n    self._v_lines: list[VLinePlot] = []\n    self._v_lines_labels: list[str | None] = []\n    self._allow_pan_and_zoom = allow_pan_and_zoom\n    self.invert_mouse_wheel = invert_mouse_wheel\n    self._x_formatter = NumericAxisFormatter()\n    self._y_formatter = NumericAxisFormatter()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.action_pan_down","title":"<code>action_pan_down()</code>","text":"<p>Pan the plot downward.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def action_pan_down(self) -&gt; None:\n    \"\"\"Pan the plot downward.\"\"\"\n    self._pan(0, -self.KEYBOARD_PAN_FACTOR)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.action_pan_left","title":"<code>action_pan_left()</code>","text":"<p>Pan the plot to the left.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def action_pan_left(self) -&gt; None:\n    \"\"\"Pan the plot to the left.\"\"\"\n    self._pan(self.KEYBOARD_PAN_FACTOR, 0)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.action_pan_right","title":"<code>action_pan_right()</code>","text":"<p>Pan the plot to the right.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def action_pan_right(self) -&gt; None:\n    \"\"\"Pan the plot to the right.\"\"\"\n    self._pan(-self.KEYBOARD_PAN_FACTOR, 0)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.action_pan_up","title":"<code>action_pan_up()</code>","text":"<p>Pan the plot upward.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def action_pan_up(self) -&gt; None:\n    \"\"\"Pan the plot upward.\"\"\"\n    self._pan(0, self.KEYBOARD_PAN_FACTOR)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.action_reset_scales","title":"<code>action_reset_scales()</code>","text":"<p>Reset the plot scales to the user-defined or auto-scaled limits.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def action_reset_scales(self) -&gt; None:\n    \"\"\"Reset the plot scales to the user-defined or auto-scaled limits.\"\"\"\n    self.set_xlimits(self._user_x_min, self._user_x_max)\n    self.set_ylimits(self._user_y_min, self._user_y_max)\n    self.post_message(\n        self.ScaleChanged(self, self._x_min, self._x_max, self._y_min, self._y_max)\n    )\n    self.refresh()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.action_zoom_x_in","title":"<code>action_zoom_x_in()</code>","text":"<p>Zoom in on the x-axis only.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def action_zoom_x_in(self) -&gt; None:\n    \"\"\"Zoom in on the x-axis only.\"\"\"\n    self._zoom_with_keyboard(self.KEYBOARD_ZOOM_FACTOR, zoom_x=True, zoom_y=False)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.action_zoom_x_out","title":"<code>action_zoom_x_out()</code>","text":"<p>Zoom out on the x-axis only.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def action_zoom_x_out(self) -&gt; None:\n    \"\"\"Zoom out on the x-axis only.\"\"\"\n    self._zoom_with_keyboard(-self.KEYBOARD_ZOOM_FACTOR, zoom_x=True, zoom_y=False)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.action_zoom_y_in","title":"<code>action_zoom_y_in()</code>","text":"<p>Zoom in on the y-axis only.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def action_zoom_y_in(self) -&gt; None:\n    \"\"\"Zoom in on the y-axis only.\"\"\"\n    self._zoom_with_keyboard(self.KEYBOARD_ZOOM_FACTOR, zoom_x=False, zoom_y=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.action_zoom_y_out","title":"<code>action_zoom_y_out()</code>","text":"<p>Zoom out on the y-axis only.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def action_zoom_y_out(self) -&gt; None:\n    \"\"\"Zoom out on the y-axis only.\"\"\"\n    self._zoom_with_keyboard(-self.KEYBOARD_ZOOM_FACTOR, zoom_x=False, zoom_y=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.add_v_line","title":"<code>add_v_line(x, line_style='white', label=None)</code>","text":"<p>Draw a vertical line on the plot.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate where the vertical line will be placed.</p> required <code>line_style</code> <code>str</code> <p>A string with the style of the line. Defaults to \"white\".</p> <code>'white'</code> <code>label</code> <code>str | None</code> <p>A string with the label for the line. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def add_v_line(\n    self, x: float, line_style: str = \"white\", label: str | None = None\n) -&gt; None:\n    \"\"\"Draw a vertical line on the plot.\n\n    Args:\n        x: The x-coordinate where the vertical line will be placed.\n        line_style: A string with the style of the line. Defaults to \"white\".\n        label: A string with the label for the line. Defaults to None.\n    \"\"\"\n    self._v_lines.append(VLinePlot(x=x, line_style=line_style))\n    self._v_lines_labels.append(label)\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.bar","title":"<code>bar(x, y, width=None, bar_style='white', hires_mode=None, label=None)</code>","text":"<p>Graph dataset using a bar plot.</p> <p>Bars are drawn as filled rectangles from y=0 to the specified y values. If you supply hires_mode, the bars will be plotted using one of the available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell characters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike | list[str]</code> <p>An ArrayLike with the x-coordinate values for the center of each bar, or a list of strings for categorical data.</p> required <code>y</code> <code>ArrayLike</code> <p>An ArrayLike with the height values for each bar.</p> required <code>width</code> <code>float | ArrayLike | None</code> <p>Width of the bars in data coordinates. Can be a single value for all bars, an array of widths for each bar, or None to auto-calculate based on spacing. Defaults to None.</p> <code>None</code> <code>bar_style</code> <code>str | list[str]</code> <p>A string with the style for all bars or a list of styles for each bar. Defaults to \"white\".</p> <code>'white'</code> <code>hires_mode</code> <code>HiResMode | None</code> <p>A HiResMode enum or None to plot with full-cell blocks. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>A string with the label for the dataset. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def bar(\n    self,\n    x: ArrayLike | list[str],\n    y: ArrayLike,\n    width: float | ArrayLike | None = None,\n    bar_style: str | list[str] = \"white\",\n    hires_mode: HiResMode | None = None,\n    label: str | None = None,\n) -&gt; None:\n    \"\"\"Graph dataset using a bar plot.\n\n    Bars are drawn as filled rectangles from y=0 to the specified y values.\n    If you supply hires_mode, the bars will be plotted using one of the\n    available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n    characters.\n\n    Args:\n        x: An ArrayLike with the x-coordinate values for the center of each bar,\n            or a list of strings for categorical data.\n        y: An ArrayLike with the height values for each bar.\n        width: Width of the bars in data coordinates. Can be a single value\n            for all bars, an array of widths for each bar, or None to auto-calculate\n            based on spacing. Defaults to None.\n        bar_style: A string with the style for all bars or a list of styles\n            for each bar. Defaults to \"white\".\n        hires_mode: A HiResMode enum or None to plot with full-cell blocks.\n            Defaults to None.\n        label: A string with the label for the dataset. Defaults to None.\n    \"\"\"\n    if isinstance(x, list) and x and isinstance(x[0], str):\n        categories = list(x)\n        x_values = np.arange(1, len(categories) + 1)\n        self.set_x_formatter(CategoricalAxisFormatter(categories))\n        self.set_xticks(x_values.tolist())\n    else:\n        x_values = np.array(x)\n\n    x_values, y_values = drop_nans_and_infs(x_values, np.array(y))\n\n    # Calculate default width if not provided\n    if width is None:\n        if len(x_values) &gt; 1:\n            # Use 80% of the minimum spacing between bars\n            spacings = np.diff(np.sort(x_values))\n            width = 0.8 * float(np.min(spacings))\n        else:\n            # Single bar, use a reasonable default\n            width = 0.8\n\n    # Convert width to array if it's a scalar\n    width_array: FloatArray\n    if isinstance(width, (int, float, np.number)):\n        width_array = np.full_like(x_values, width, dtype=float)\n    else:\n        width_array = np.array(width, dtype=float)\n\n    self._datasets.append(\n        BarPlot(\n            x=x_values,\n            y=y_values,\n            width=width_array,\n            bar_style=bar_style,\n            hires_mode=hires_mode,\n        )\n    )\n    self._labels.append(label)\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.clear","title":"<code>clear()</code>","text":"<p>Clear the plot canvas.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the plot canvas.\"\"\"\n    self._datasets = []\n    self._labels = []\n    self._v_lines = []\n    self._v_lines_labels = []\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.combine_quad_with_pixel","title":"<code>combine_quad_with_pixel(quad, canvas, x, y)</code>","text":"<p>Combine a box-drawing quad with an existing pixel to create seamless connections.</p> <p>Parameters:</p> Name Type Description Default <code>quad</code> <code>tuple[int, int, int, int]</code> <p>A tuple of 4 integers representing box drawing directions (top, right, bottom, left).</p> required <code>canvas</code> <code>Canvas</code> <p>The canvas containing the pixel.</p> required <code>x</code> <code>int</code> <p>X-coordinate of the pixel.</p> required <code>y</code> <code>int</code> <p>Y-coordinate of the pixel.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A box-drawing character that combines both quads.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def combine_quad_with_pixel(\n    self, quad: tuple[int, int, int, int], canvas: Canvas, x: int, y: int\n) -&gt; str:\n    \"\"\"Combine a box-drawing quad with an existing pixel to create seamless connections.\n\n    Args:\n        quad: A tuple of 4 integers representing box drawing directions (top, right, bottom, left).\n        canvas: The canvas containing the pixel.\n        x: X-coordinate of the pixel.\n        y: Y-coordinate of the pixel.\n\n    Returns:\n        A box-drawing character that combines both quads.\n    \"\"\"\n    pixel = canvas.get_pixel(x, y)[0]\n    for current_quad, v in BOX_CHARACTERS.items():\n        if v == pixel:\n            break\n    else:\n        raise ValueError(f\"Pixel '{pixel}' is not a valid box drawing character.\")\n    new_quad = combine_quads(current_quad, quad)\n    return BOX_CHARACTERS[new_quad]\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.compose","title":"<code>compose()</code>","text":"<p>Compose the child widgets of the PlotWidget.</p> <p>Returns:</p> Type Description <code>ComposeResult</code> <p>An iterable of child widgets including the plot canvas, margins, and legend.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compose the child widgets of the PlotWidget.\n\n    Returns:\n        An iterable of child widgets including the plot canvas, margins, and legend.\n    \"\"\"\n    with Grid():\n        yield Canvas(1, 1, id=\"margin-top\")\n        yield Canvas(1, 1, id=\"margin-left\")\n        yield Canvas(1, 1, id=\"plot\")\n        yield Canvas(1, 1, id=\"margin-bottom\")\n    yield Legend(id=\"legend\")\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.drag_with_mouse","title":"<code>drag_with_mouse(event)</code>","text":"<p>Handle mouse drag operations for panning the plot or the legend.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseMove</code> <p>The mouse move event.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>@on(MouseMove)\ndef drag_with_mouse(self, event: MouseMove) -&gt; None:\n    \"\"\"Handle mouse drag operations for panning the plot or the legend.\n\n    Args:\n        event: The mouse move event.\n    \"\"\"\n    if not self._allow_pan_and_zoom:\n        return\n    if event.button == 0:\n        # If no button is pressed, don't drag.\n        return\n\n    if self._is_dragging_legend:\n        self._drag_legend(event)\n    else:\n        self._pan_plot_with_mouse(event)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.errorbar","title":"<code>errorbar(x, y, xerr=None, yerr=None, marker='', marker_style='white', hires_mode=None, label=None)</code>","text":"<p>Graph dataset using an error bar plot.</p> <p>Error bars are rendered to half-cell resolution. If the error bars become very small and no marker is specified, a dot is rendered at the location of the data point. The markers are rendered last so that error bars never obscure the data points.</p> <p>If you supply hires_mode, the data points will be plotted using one of the available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell characters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the horizontal axis.</p> required <code>y</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the vertical axis.</p> required <code>xerr</code> <code>ArrayLike | None</code> <p>An ArrayLike with the error values for the horizontal axis, or None for no x errors. Defaults to None.</p> <code>None</code> <code>yerr</code> <code>ArrayLike | None</code> <p>An ArrayLike with the error values for the vertical axis, or None for no y errors. Defaults to None.</p> <code>None</code> <code>marker</code> <code>str</code> <p>A string with the character to print as the marker.</p> <code>''</code> <code>marker_style</code> <code>str</code> <p>A string with the style of the marker. Defaults to \"white\".</p> <code>'white'</code> <code>hires_mode</code> <code>HiResMode | None</code> <p>A HiResMode enum or None to plot with the supplied marker. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>A string with the label for the dataset. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def errorbar(\n    self,\n    x: ArrayLike,\n    y: ArrayLike,\n    xerr: ArrayLike | None = None,\n    yerr: ArrayLike | None = None,\n    marker: str = \"\",\n    marker_style: str = \"white\",\n    hires_mode: HiResMode | None = None,\n    label: str | None = None,\n) -&gt; None:\n    \"\"\"Graph dataset using an error bar plot.\n\n    Error bars are rendered to half-cell resolution. If the error bars\n    become very small and no marker is specified, a dot is rendered at the\n    location of the data point. The markers are rendered last so that error\n    bars never obscure the data points.\n\n    If you supply hires_mode, the data points will be plotted using one of\n    the available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n    characters.\n\n    Args:\n        x: An ArrayLike with the data values for the horizontal axis.\n        y: An ArrayLike with the data values for the vertical axis.\n        xerr: An ArrayLike with the error values for the horizontal axis,\n            or None for no x errors. Defaults to None.\n        yerr: An ArrayLike with the error values for the vertical axis,\n            or None for no y errors. Defaults to None.\n        marker: A string with the character to print as the marker.\n        marker_style: A string with the style of the marker. Defaults to\n            \"white\".\n        hires_mode: A HiResMode enum or None to plot with the supplied\n            marker. Defaults to None.\n        label: A string with the label for the dataset. Defaults to None.\n    \"\"\"\n    x, y = drop_nans_and_infs(np.array(x), np.array(y))\n\n    # Convert error arrays to numpy arrays if provided\n    xerr_array = np.array(xerr) if xerr is not None else np.zeros(shape=x.shape)\n    yerr_array = np.array(yerr) if yerr is not None else np.zeros(shape=y.shape)\n\n    self._datasets.append(\n        ErrorBarPlot(\n            x=x,\n            y=y,\n            xerr=xerr_array,\n            yerr=yerr_array,\n            marker=marker,\n            marker_style=marker_style,\n            hires_mode=hires_mode,\n        )\n    )\n    self._labels.append(label)\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.get_coordinate_from_pixel","title":"<code>get_coordinate_from_pixel(x, y)</code>","text":"<p>Convert canvas pixel coordinates to data coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X-coordinate in pixel space.</p> required <code>y</code> <code>int</code> <p>Y-coordinate in pixel space.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>A tuple of (x, y) coordinates in data space.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def get_coordinate_from_pixel(self, x: int, y: int) -&gt; tuple[float, float]:\n    \"\"\"Convert canvas pixel coordinates to data coordinates.\n\n    Args:\n        x: X-coordinate in pixel space.\n        y: Y-coordinate in pixel space.\n\n    Returns:\n        A tuple of (x, y) coordinates in data space.\n    \"\"\"\n    return map_pixel_to_coordinate(\n        x,\n        y,\n        self._x_min,\n        self._x_max,\n        self._y_min,\n        self._y_max,\n        region=self._scale_rectangle,\n    )\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.get_hires_pixel_from_coordinate","title":"<code>get_hires_pixel_from_coordinate(x, y)</code>","text":"<p>Convert data coordinates to high-resolution pixel coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>FloatScalar</code> <p>X-coordinate in data space.</p> required <code>y</code> <code>FloatScalar</code> <p>Y-coordinate in data space.</p> required <p>Returns:</p> Type Description <code>tuple[FloatScalar, FloatScalar]</code> <p>A tuple of (x, y) high-resolution pixel coordinates with sub-character precision.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def get_hires_pixel_from_coordinate(\n    self, x: FloatScalar, y: FloatScalar\n) -&gt; tuple[FloatScalar, FloatScalar]:\n    \"\"\"Convert data coordinates to high-resolution pixel coordinates.\n\n    Args:\n        x: X-coordinate in data space.\n        y: Y-coordinate in data space.\n\n    Returns:\n        A tuple of (x, y) high-resolution pixel coordinates with sub-character precision.\n    \"\"\"\n    return map_coordinate_to_hires_pixel(\n        x,\n        y,\n        self._x_min,\n        self._x_max,\n        self._y_min,\n        self._y_max,\n        region=self._scale_rectangle,\n    )\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.get_pixel_from_coordinate","title":"<code>get_pixel_from_coordinate(x, y)</code>","text":"<p>Convert data coordinates to canvas pixel coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>FloatScalar</code> <p>X-coordinate in data space.</p> required <code>y</code> <code>FloatScalar</code> <p>Y-coordinate in data space.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>A tuple of (x, y) pixel coordinates on the canvas.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def get_pixel_from_coordinate(\n    self, x: FloatScalar, y: FloatScalar\n) -&gt; tuple[int, int]:\n    \"\"\"Convert data coordinates to canvas pixel coordinates.\n\n    Args:\n        x: X-coordinate in data space.\n        y: Y-coordinate in data space.\n\n    Returns:\n        A tuple of (x, y) pixel coordinates on the canvas.\n    \"\"\"\n    return map_coordinate_to_pixel(\n        x,\n        y,\n        self._x_min,\n        self._x_max,\n        self._y_min,\n        self._y_max,\n        region=self._scale_rectangle,\n    )\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.notify_style_update","title":"<code>notify_style_update()</code>","text":"<p>Called when styles update (e.g., theme change). Rerender the plot.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def notify_style_update(self) -&gt; None:\n    \"\"\"Called when styles update (e.g., theme change). Rerender the plot.\"\"\"\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.on_mount","title":"<code>on_mount()</code>","text":"<p>Initialize the plot widget when mounted to the DOM.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"Initialize the plot widget when mounted to the DOM.\"\"\"\n    self._update_margin_sizes()\n    self.set_xlimits(None, None)\n    self.set_ylimits(None, None)\n    self.clear()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.plot","title":"<code>plot(x, y, line_style='white', hires_mode=None, label=None)</code>","text":"<p>Graph dataset using a line plot.</p> <p>If you supply hires_mode, the dataset will be plotted using one of the available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell characters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the horizontal axis.</p> required <code>y</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the vertical axis.</p> required <code>line_style</code> <code>str</code> <p>A string with the style of the line. Defaults to \"white\".</p> <code>'white'</code> <code>hires_mode</code> <code>HiResMode | None</code> <p>A HiResMode enum or None to plot with full-height blocks. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>A string with the label for the dataset. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def plot(\n    self,\n    x: ArrayLike,\n    y: ArrayLike,\n    line_style: str = \"white\",\n    hires_mode: HiResMode | None = None,\n    label: str | None = None,\n) -&gt; None:\n    \"\"\"Graph dataset using a line plot.\n\n    If you supply hires_mode, the dataset will be plotted using one of the\n    available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n    characters.\n\n    Args:\n        x: An ArrayLike with the data values for the horizontal axis.\n        y: An ArrayLike with the data values for the vertical axis.\n        line_style: A string with the style of the line. Defaults to\n            \"white\".\n        hires_mode: A HiResMode enum or None to plot with full-height\n            blocks. Defaults to None.\n        label: A string with the label for the dataset. Defaults to None.\n    \"\"\"\n    x, y = drop_nans_and_infs(np.array(x), np.array(y))\n    self._datasets.append(\n        LinePlot(\n            x=x,\n            y=y,\n            line_style=line_style,\n            hires_mode=hires_mode,\n        )\n    )\n    self._labels.append(label)\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.refresh","title":"<code>refresh(*regions, repaint=True, layout=False, recompose=False)</code>","text":"<p>Refresh the widget.</p> <p>Parameters:</p> Name Type Description Default <code>regions</code> <code>Region</code> <p>Specific regions to refresh.</p> <code>()</code> <code>repaint</code> <code>bool</code> <p>Whether to repaint the widget. Defaults to True.</p> <code>True</code> <code>layout</code> <code>bool</code> <p>Whether to refresh the layout. Defaults to False.</p> <code>False</code> <code>recompose</code> <code>bool</code> <p>Whether to recompose the widget. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>The widget instance for method chaining.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def refresh(\n    self,\n    *regions: Region,\n    repaint: bool = True,\n    layout: bool = False,\n    recompose: bool = False,\n) -&gt; Self:\n    \"\"\"Refresh the widget.\n\n    Args:\n        regions: Specific regions to refresh.\n        repaint: Whether to repaint the widget. Defaults to True.\n        layout: Whether to refresh the layout. Defaults to False.\n        recompose: Whether to recompose the widget. Defaults to False.\n\n    Returns:\n        The widget instance for method chaining.\n    \"\"\"\n    if layout is True:\n        self._needs_rerender = True\n    return super().refresh(\n        *regions, repaint=repaint, layout=layout, recompose=recompose\n    )\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.render","title":"<code>render()</code>","text":"<p>Render the plot widget.</p> <p>Returns:</p> Type Description <code>RenderResult</code> <p>An empty string as rendering is done on canvases.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def render(self) -&gt; RenderResult:\n    \"\"\"Render the plot widget.\n\n    Returns:\n        An empty string as rendering is done on canvases.\n    \"\"\"\n    if self._needs_rerender:\n        self._needs_rerender = False\n        self._render_plot()\n    return \"\"\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.scatter","title":"<code>scatter(x, y, marker='o', marker_style='white', hires_mode=None, label=None)</code>","text":"<p>Graph dataset using a scatter plot.</p> <p>If you supply hires_mode, the dataset will be plotted using one of the available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell characters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the horizontal axis.</p> required <code>y</code> <code>ArrayLike</code> <p>An ArrayLike with the data values for the vertical axis.</p> required <code>marker</code> <code>str</code> <p>A string with the character to print as the marker.</p> <code>'o'</code> <code>marker_style</code> <code>str</code> <p>A string with the style of the marker. Defaults to \"white\".</p> <code>'white'</code> <code>hires_mode</code> <code>HiResMode | None</code> <p>A HiResMode enum or None to plot with the supplied marker. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>A string with the label for the dataset. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def scatter(\n    self,\n    x: ArrayLike,\n    y: ArrayLike,\n    marker: str = \"o\",\n    marker_style: str = \"white\",\n    hires_mode: HiResMode | None = None,\n    label: str | None = None,\n) -&gt; None:\n    \"\"\"Graph dataset using a scatter plot.\n\n    If you supply hires_mode, the dataset will be plotted using one of the\n    available high-resolution modes like 1x2, 2x2 or 2x8 pixel-per-cell\n    characters.\n\n    Args:\n        x: An ArrayLike with the data values for the horizontal axis.\n        y: An ArrayLike with the data values for the vertical axis.\n        marker: A string with the character to print as the marker.\n        marker_style: A string with the style of the marker. Defaults to\n            \"white\".\n        hires_mode: A HiResMode enum or None to plot with the supplied\n            marker. Defaults to None.\n        label: A string with the label for the dataset. Defaults to None.\n    \"\"\"\n    x, y = drop_nans_and_infs(np.array(x), np.array(y))\n    self._datasets.append(\n        ScatterPlot(\n            x=x,\n            y=y,\n            marker=marker,\n            marker_style=marker_style,\n            hires_mode=hires_mode,\n        )\n    )\n    self._labels.append(label)\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_x_formatter","title":"<code>set_x_formatter(formatter)</code>","text":"<p>Set the formatter for the x axis.</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>AxisFormatter</code> <p>An AxisFormatter instance to use for formatting x-axis ticks.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_x_formatter(self, formatter: AxisFormatter) -&gt; None:\n    \"\"\"Set the formatter for the x axis.\n\n    Args:\n        formatter: An AxisFormatter instance to use for formatting x-axis ticks.\n    \"\"\"\n    self._x_formatter = formatter\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_xlabel","title":"<code>set_xlabel(label)</code>","text":"<p>Set a label for the x axis.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>A string with the label text.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_xlabel(self, label: str) -&gt; None:\n    \"\"\"Set a label for the x axis.\n\n    Args:\n        label: A string with the label text.\n    \"\"\"\n    self._x_label = label\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_xlimits","title":"<code>set_xlimits(xmin=None, xmax=None)</code>","text":"<p>Set the limits of the x axis.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float | None</code> <p>A float with the minimum x value or None for autoscaling. Defaults to None.</p> <code>None</code> <code>xmax</code> <code>float | None</code> <p>A float with the maximum x value or None for autoscaling. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_xlimits(self, xmin: float | None = None, xmax: float | None = None) -&gt; None:\n    \"\"\"Set the limits of the x axis.\n\n    Args:\n        xmin: A float with the minimum x value or None for autoscaling.\n            Defaults to None.\n        xmax: A float with the maximum x value or None for autoscaling.\n            Defaults to None.\n    \"\"\"\n    self._user_x_min = xmin\n    self._user_x_max = xmax\n    self._auto_x_min = xmin is None\n    self._auto_x_max = xmax is None\n    self._x_min = xmin if xmin is not None else 0.0\n    self._x_max = xmax if xmax is not None else 1.0\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_xticks","title":"<code>set_xticks(ticks=None)</code>","text":"<p>Set the x axis ticks.</p> <p>Use None for autoscaling, an empty list to hide the ticks.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>Sequence[float] | None</code> <p>An iterable with the tick values.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_xticks(self, ticks: Sequence[float] | None = None) -&gt; None:\n    \"\"\"Set the x axis ticks.\n\n    Use None for autoscaling, an empty list to hide the ticks.\n\n    Args:\n        ticks: An iterable with the tick values.\n    \"\"\"\n    self._x_ticks = ticks\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_y_formatter","title":"<code>set_y_formatter(formatter)</code>","text":"<p>Set the formatter for the y axis.</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>AxisFormatter</code> <p>An AxisFormatter instance to use for formatting y-axis ticks.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_y_formatter(self, formatter: AxisFormatter) -&gt; None:\n    \"\"\"Set the formatter for the y axis.\n\n    Args:\n        formatter: An AxisFormatter instance to use for formatting y-axis ticks.\n    \"\"\"\n    self._y_formatter = formatter\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_ylabel","title":"<code>set_ylabel(label)</code>","text":"<p>Set a label for the y axis.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>A string with the label text.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_ylabel(self, label: str) -&gt; None:\n    \"\"\"Set a label for the y axis.\n\n    Args:\n        label: A string with the label text.\n    \"\"\"\n    self._y_label = label\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_ylimits","title":"<code>set_ylimits(ymin=None, ymax=None)</code>","text":"<p>Set the limits of the y axis.</p> <p>Parameters:</p> Name Type Description Default <code>ymin</code> <code>float | None</code> <p>A float with the minimum y value or None for autoscaling. Defaults to None.</p> <code>None</code> <code>ymax</code> <code>float | None</code> <p>A float with the maximum y value or None for autoscaling. Defaults to None.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_ylimits(self, ymin: float | None = None, ymax: float | None = None) -&gt; None:\n    \"\"\"Set the limits of the y axis.\n\n    Args:\n        ymin: A float with the minimum y value or None for autoscaling.\n            Defaults to None.\n        ymax: A float with the maximum y value or None for autoscaling.\n            Defaults to None.\n    \"\"\"\n    self._user_y_min = ymin\n    self._user_y_max = ymax\n    self._auto_y_min = ymin is None\n    self._auto_y_max = ymax is None\n    self._y_min = ymin if ymin is not None else 0.0\n    self._y_max = ymax if ymax is not None else 1.0\n    self.refresh(layout=True)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.set_yticks","title":"<code>set_yticks(ticks=None)</code>","text":"<p>Set the y axis ticks.</p> <p>Use None for autoscaling, an empty list to hide the ticks.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>Sequence[float] | None</code> <p>An iterable with the tick values.</p> <code>None</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def set_yticks(self, ticks: Sequence[float] | None = None) -&gt; None:\n    \"\"\"Set the y axis ticks.\n\n    Use None for autoscaling, an empty list to hide the ticks.\n\n    Args:\n        ticks: An iterable with the tick values.\n    \"\"\"\n    self._y_ticks = ticks\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.show_legend","title":"<code>show_legend(location=LegendLocation.TOPRIGHT, is_visible=True)</code>","text":"<p>Show or hide the legend for the datasets in the plot.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>A boolean indicating whether to show the legend. Defaults to True.</p> <code>True</code> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def show_legend(\n    self,\n    location: LegendLocation = LegendLocation.TOPRIGHT,\n    is_visible: bool = True,\n) -&gt; None:\n    \"\"\"Show or hide the legend for the datasets in the plot.\n\n    Args:\n        is_visible: A boolean indicating whether to show the legend.\n            Defaults to True.\n    \"\"\"\n    self.query_one(\"#legend\", Static).display = is_visible\n    if not is_visible:\n        return\n\n    self._position_legend()\n\n    legend_lines = []\n    if isinstance(location, LegendLocation):\n        self._legend_location = location\n    else:\n        raise TypeError(\n            f\"Expected LegendLocation, got {type(location).__name__} instead.\"\n        )\n\n    for label, dataset in zip(self._labels, self._datasets):\n        if label is not None:\n            if isinstance(dataset, LinePlot):\n                marker = LEGEND_LINE[dataset.hires_mode]\n                style = dataset.line_style\n            elif isinstance(dataset, ErrorBarPlot):\n                marker = (\n                    dataset.marker or \"\u253c\"\n                    if dataset.hires_mode is None\n                    else LEGEND_MARKER[dataset.hires_mode]\n                ).center(3)\n                style = dataset.marker_style\n            elif isinstance(dataset, BarPlot):\n                marker = \"\u2588\u2588\u2588\"\n                # Use first style if bar_style is a list\n                style = (\n                    dataset.bar_style[0]\n                    if isinstance(dataset.bar_style, list)\n                    else dataset.bar_style\n                )\n            elif isinstance(dataset, ScatterPlot):\n                marker = (\n                    dataset.marker\n                    if dataset.hires_mode is None\n                    else LEGEND_MARKER[dataset.hires_mode]\n                ).center(3)\n                style = dataset.marker_style\n            else:\n                # unsupported dataset type\n                continue\n            text = Text(marker)\n            text.stylize(style)\n            text.append(f\" {label}\")\n            legend_lines.append(text.markup)\n\n    for label, vline in zip(self._v_lines_labels, self._v_lines):\n        if label is not None:\n            marker = \"\u2502\".center(3)\n            style = vline.line_style\n            text = Text(marker)\n            text.stylize(style)\n            text.append(f\" {label}\")\n            legend_lines.append(text.markup)\n\n    self.query_one(\"#legend\", Static).update(\n        Text.from_markup(\"\\n\".join(legend_lines))\n    )\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.start_dragging_legend","title":"<code>start_dragging_legend(event)</code>","text":"<p>Start dragging the legend when clicked with left mouse button.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseDown</code> <p>The mouse down event.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>@on(MouseDown)\ndef start_dragging_legend(self, event: MouseDown) -&gt; None:\n    \"\"\"Start dragging the legend when clicked with left mouse button.\n\n    Args:\n        event: The mouse down event.\n    \"\"\"\n    widget, _ = self.screen.get_widget_at(event.screen_x, event.screen_y)\n    if event.button == 1 and widget.id == \"legend\":\n        self._is_dragging_legend = True\n        widget.add_class(\"dragged\")\n        event.stop()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.stop_dragging_legend","title":"<code>stop_dragging_legend(event)</code>","text":"<p>Stop dragging the legend when left mouse button is released.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseUp</code> <p>The mouse up event.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>@on(MouseUp)\ndef stop_dragging_legend(self, event: MouseUp) -&gt; None:\n    \"\"\"Stop dragging the legend when left mouse button is released.\n\n    Args:\n        event: The mouse up event.\n    \"\"\"\n    if event.button == 1 and self._is_dragging_legend:\n        self._is_dragging_legend = False\n        self.query_one(\"#legend\").remove_class(\"dragged\")\n        event.stop()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.watch_margin_bottom","title":"<code>watch_margin_bottom()</code>","text":"<p>React to changes in the bottom margin reactive attribute.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def watch_margin_bottom(self) -&gt; None:\n    \"\"\"React to changes in the bottom margin reactive attribute.\"\"\"\n    self._update_margin_sizes()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.watch_margin_left","title":"<code>watch_margin_left()</code>","text":"<p>React to changes in the left margin reactive attribute.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def watch_margin_left(self) -&gt; None:\n    \"\"\"React to changes in the left margin reactive attribute.\"\"\"\n    self._update_margin_sizes()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.watch_margin_top","title":"<code>watch_margin_top()</code>","text":"<p>React to changes in the top margin reactive attribute.</p> Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>def watch_margin_top(self) -&gt; None:\n    \"\"\"React to changes in the top margin reactive attribute.\"\"\"\n    self._update_margin_sizes()\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.zoom_in","title":"<code>zoom_in(event)</code>","text":"<p>Zoom into the plot when scrolling down.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseScrollDown</code> <p>The mouse scroll down event.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>@on(MouseScrollDown)\ndef zoom_in(self, event: MouseScrollDown) -&gt; None:\n    \"\"\"Zoom into the plot when scrolling down.\n\n    Args:\n        event: The mouse scroll down event.\n    \"\"\"\n    event.stop()\n    self._zoom_with_mouse(event, self.MOUSE_ZOOM_FACTOR)\n</code></pre>"},{"location":"reference/#textual_plot.PlotWidget.zoom_out","title":"<code>zoom_out(event)</code>","text":"<p>Zoom out of the plot when scrolling up.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseScrollUp</code> <p>The mouse scroll up event.</p> required Source code in <code>src/textual_plot/plot_widget.py</code> <pre><code>@on(MouseScrollUp)\ndef zoom_out(self, event: MouseScrollUp) -&gt; None:\n    \"\"\"Zoom out of the plot when scrolling up.\n\n    Args:\n        event: The mouse scroll up event.\n    \"\"\"\n    event.stop()\n    self._zoom_with_mouse(event, -self.MOUSE_ZOOM_FACTOR)\n</code></pre>"}]}